{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"How we teach","text":""},{"location":"#projects","title":"Projects","text":"<p>We believe that the best learning experience is by creating with a clear goal. All our courses are project-based, meaning you're applying concepts in real-world scenarios, enhancing your understanding. </p>"},{"location":"#code-snippets","title":"Code Snippets","text":"<p>How can you learn coding without helpfuls snippets? We use actual code, with actual line numbers, highliting changes as you work your way through the class.</p> <pre><code># Run an agent\nagent.run(\"Teach me Griptape!\")\n</code></pre>"},{"location":"#text-video-whatever","title":"Text, Video, Whatever","text":"<p>Some concepts are taught best through text. Others through video. And still others require both.</p> <p>We're happy to provide all of it!</p>"},{"location":"#how-can-we-help","title":"How can we help?","text":"<p>We love any and all feedback!</p> <p>Do you have a new idea for a course? Drop us a line in our Discord, or log a rquest at Griptape Trade School Github!</p>"},{"location":"contributing/","title":"Contributions or Issues","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>We greatly appreciate contributions and help creating and maintaining courses and tutorials.</p>"},{"location":"contributing/#reports-and-issues","title":"Reports and Issues","text":"<p>The easiest way to contribute to these tutorials is through our public issue tracker. Feel free to submit bugs, request features or changes, or chat with us directly on Discord.</p>"},{"location":"courses/","title":"All Courses","text":""},{"location":"courses/#create-a-chatbot-using-griptape-rulesets","title":"Create a Chatbot using Griptape Rulesets","text":"<p>Take a deep dive into creating a conversational chatbot with an Agent using Griptape's Rulesets. Not only will our chatbot be able to engage in conversation, but it will also have the unique ability to embody different personalities.</p> <p> Take the course</p>"},{"location":"courses/#compare-movies-using-griptape-workflows","title":"Compare Movies using Griptape Workflows","text":"<p>Learn how to work with Griptape Workflow Structures to create flexable and powerful hierarchies of tasks. This course demonstrates these concepts by comparing movies, utilizing PromptTasks and ToolkitTasks to analyze text and search the web.</p> <p> Take the course</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"100/","title":"100 Beginner - \"Kickflip\"","text":"<p>Dive into the world of Griptape in our Beginner courses, where we lay the groundwork for your coding journey. You'll explore the fundamentals of our Python library and familiarize yourself with core concepts that form the bedrock of Griptape. These courses are designed to equip you with a solid base, setting the stage for more advanced Griptape adventures.</p> <p>Why Kickflip?</p> <p>The kickflip, in skateboarding, is one of the first tricks a skater learns. It involves flipping the board in the air using a 'kick' motion with the foot. It's an essential move that forms the foundation for many other tricks, much like our Beginner courses which lay the groundwork for your journey with Griptape. This trick gets its name from the 'kick' action used to flip the board.</p>"},{"location":"200/","title":"200 Intermediate - \"Grind\"","text":"<p>Ready to put your foundational knowledge into practice? Welcome to our Intermediate courses, where we roll up our sleeves and dive into project-based learning. These courses are designed to combine core concepts with advanced features, paving the way for intriguing and complex solutions. Here, you'll apply your skills, gain insights, and experience firsthand how Griptape can elevate your projects.</p> <p>Why Grind?</p> <p>Grinding, in the world of skateboarding, refers to sliding along an edge (like a rail or curb) using the trucks of the skateboard. It's a step up from basic tricks, requiring a combination of balance, speed, and precision\u2014mirroring our Intermediate level where you'll apply and integrate core concepts of Griptape into more complex projects. The term 'grind' is derived from the scraping or 'grinding' sound and action produced during the trick.</p>"},{"location":"200/#courses","title":"Courses","text":"Course Description Multiple Personality Chatbot In this course, we will take a deep dive into creating a conversational chatbot with an Agent using Griptape's Rulesets. Not only will our chatbot be able to engage in conversation, but it will also have the unique ability to embody different personalities."},{"location":"200/chatbot-rulesets/","title":"Building a Conversational Chatbot with Personality Using Griptape's Rulesets","text":""},{"location":"200/chatbot-rulesets/#course-description","title":"Course Description","text":"<p>In this course, we will take a deep dive into creating a command-line interface (CLI) based conversational chatbot with an Agent using Griptape's Rulesets. Not only will our chatbot be able to engage in conversation, but it will also have the unique ability to embody different personalities, making the interaction more dynamic and interesting. </p> <p>You will get hands-on experience working with Griptape, understanding and implementing Rulesets, and using Agents to bring your chatbot to life. This course serves as an excellent introduction to these concepts and technologies.</p>"},{"location":"200/chatbot-rulesets/#who-is-this-course-for","title":"Who is this course for?","text":"<p>This course is aimed at beginners to intermediate level Python developers who are interested in learning more about Griptape.</p>"},{"location":"200/chatbot-rulesets/#prerequisites","title":"Prerequisites","text":"<p>Before beginning this course, you will need:</p> <ul> <li>An OpenAI API Key (available here: https://beta.openai.com/account/api-keys)</li> <li>Python3.9+ installed on your machine</li> <li>An IDE (such as Visual Studio Code or PyCharm) to write and manage your code</li> </ul> <p>If you don't have those items available, it's highly recommended you go through the Griptape Setup - Visual Studio Code course to set up your environment.</p>"},{"location":"200/chatbot-rulesets/#course-outline","title":"Course Outline","text":"<p>The course is designed to progressively build your understanding and skillset. We'll start with setting up your environment, then introduce you to the basics of Agents and Rulesets. We'll add more advanced features as the course progresses, including:</p> <ul> <li>Making your chatbot interactive</li> <li>Giving your chatbot a personality</li> <li>Enhancing chat aesthetics</li> <li>Enabling your chatbot to switch between multiple personas</li> <li>And more!</li> </ul> <p>By the end of this course, you'll have a versatile chatbot that can carry on engaging conversations with varying personas, right from your command line.</p>"},{"location":"200/chatbot-rulesets/#useful-resources","title":"Useful Resources","text":"<p>These resources will provide additional information and context throughout the course:</p> <ul> <li>Griptape Documentation</li> <li>Python-dotenv Package</li> <li>Rich Library</li> <li>Visual Studio Code</li> <li>Python Environment Manager</li> </ul>"},{"location":"200/chatbot-rulesets/#next-steps","title":"Next Steps","text":"<p>Head on to the first stage 01 - Setting Up Your Environment to get started!</p>"},{"location":"200/chatbot-rulesets/01_setting_up_environment/","title":"Setup","text":"<p>Welcome to the first step of our journey into creating a conversational chatbot! In this section, we will be focusing on setting up our work environment, which is the first step to any coding project. </p>"},{"location":"200/chatbot-rulesets/01_setting_up_environment/#prerequisites","title":"Prerequisites","text":"<p>Important</p> <p>Since this is an intermediate level course, please ensure you've gone through the Griptape Setup - Visual Studio Code course to set up your environment. We will be starting from the code at that point.</p> <ol> <li> <p>Code Editor: We recommend using Visual Studio Code for this course, due to its handy features and Python support. However, if you have another favorite IDE or text editor, feel free to use that! </p> </li> <li> <p>Python3.9+: Griptape requires Python 3.9 and above.</p> </li> <li> <p>Python Environment Manager (for VS Code users): This extension is not a hard requirement, but it does make managing your Python environments a lot easier. </p> </li> <li> <p>OpenAI API Key: Our chatbot will be powered by gpt-4, which requires an API key from OpenAI. You can get your key from OpenAI's website.</p> </li> </ol> <p>Got everything installed? Awesome! Now, let's get started setting up our project.</p>"},{"location":"200/chatbot-rulesets/01_setting_up_environment/#create-a-project","title":"Create a Project","text":"<p>Following the instructions in Griptape Setup - Visual Studio Code  please:</p> <ol> <li>Create your project folder. Example: <code>griptape-chatbot-with-rulesets-cli</code></li> <li>Set up your virtual environment</li> <li>Ensure you <code>pip install griptape griptape-tools python-dotenv</code></li> <li>Create a <code>.env</code> file with your <code>OPENAI_API_KEY</code></li> <li>Create your <code>app.py</code> file with the following code:</li> </ol> <pre><code>from dotenv import load_dotenv\nfrom griptape.structures import Agent\nload_dotenv() # Load your environment\n# Create an agent\nagent = Agent()\n# Run the agent\nagent.run(\"I'm ready to chat.\")\n</code></pre> <p>And there we have it, our coding environment is all set up! In the next section The Chat Utility, we'll look at one of the quickest ways of creating a Chatbot with Griptape.</p>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/","title":"The Chat Utility","text":""},{"location":"200/chatbot-rulesets/03_the_chat_utility/#make-agent-interactive-using-chat-utility","title":"Make Agent Interactive Using Chat Utility","text":"<p>Now that we have our agent up and running, it's time to make it truly interactive and engaging. We'll introduce the Chat utility from Griptape, which is a quick way to have dynamic conversations with our chatbot. Get ready to dive into the world of witty banter and Python-powered humor!</p>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#goal","title":"Goal","text":"<p>After completing this section, you'll be able to have lively and interactive conversations with your chatbot using the Chat utility.</p>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#chat-utility","title":"Chat Utility","text":""},{"location":"200/chatbot-rulesets/03_the_chat_utility/#import","title":"Import","text":"<p>To get started, we need to import the magical <code>Chat</code> utility from Griptape. This utility will be our ticket to engaging conversations with our chatbot. In your code, add the following import statement:</p> app.py<pre><code># ... previous code\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\n# ...\n</code></pre> <p>With the Chat utility at our disposal, we're armed with the power to unleash our chatbot's conversational prowess.</p>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#call-it","title":"Call It","text":"<p>It's time to unleash our chatbot's conversational skills and start the interactive chat session. Replace the previous <code>agent.run()</code> line with the following code:</p> <pre><code># ...\n# Begin Chatting\nChat(agent).start()\n</code></pre> <p>This simple line of code will open up a world of possibilities, allowing you to converse with your chatbot as if it were your witty Python companion.</p>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#current-code","title":"Current Code","text":"<p>Here is the full code: </p> app.py<pre><code>from dotenv import load_dotenv\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat #   &lt;-- Added Chat\n# Load environment variables\nload_dotenv()\n# Create the agent\nagent = Agent()\n# Begin Chatting\nChat(agent).start()\n</code></pre>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#try-it","title":"Try it","text":"<p>It's time to play around with your chatbot. Ask it some questions, have a laugh, etc. Here's a quick example of a not-very-funny joke with the chatbot:</p> <pre><code>Q: Hello!\nprocessing...\n[07/20/23 06:37:45] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Input: Hello!                                                                                                                                           \n[07/20/23 06:37:46] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Output: Hello! How can I assist you today?                                                                                                              \nA: Hello! How can I assist you today?\nQ: Tell me a joke about python\nprocessing...\n[07/20/23 06:37:58] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Input: Tell me a joke about python                                                                                                                      \n[07/20/23 06:38:00] INFO     Task 167f55dda2be46a7bc9002a48214dbf4                                                                                                                   \n                             Output: Why did the python programmer get bitten by a snake? Because they forgot to use a python exception handler!                                     \nA: Why did the python programmer get bitten by a snake? Because they forgot to use a python exception handler!\n</code></pre>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#exiting","title":"Exiting","text":"<p>Conversations must come to an end, even with the most entertaining chatbot. We want to gracefully exit the chat session when we're ready to bid our virtual friend farewell. To exit the chat, simply type <code>exit</code> as your input. The Chat utility will catch this magic word and gracefully end the conversation.</p> <p>So go ahead, chat away, exchange jokes, discuss Python's quirks, and when it's time to say goodbye, just type <code>exit</code> and gracefully conclude your interaction.</p> <pre><code>Q: exit\nexiting...\n</code></pre>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#code-review","title":"Code Review","text":"<p>Take a minute to check your code against the current version.</p> app.py<pre><code>from dotenv import load_dotenv\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat #   &lt;-- Added Chat\n# Load environment variables\nload_dotenv()\n# Create the agent\nagent = Agent()\n# Begin Chatting\nChat(agent).start()\n</code></pre>"},{"location":"200/chatbot-rulesets/03_the_chat_utility/#next-steps","title":"Next Steps","text":"<p>In the next section: Hide The Logs, we'll hide those pesky but oh-so-helpful logs by using the <code>logging</code> library. This will make our chatbot much easier to understand and work with.</p>"},{"location":"200/chatbot-rulesets/04_hide_the_logs/","title":"Hiding the Logs","text":"<p>In the previous section, we had a blast engaging with our chatbot, but there was one tiny detail that interrupted the flow of our conversations - those verbose logs cluttering our output. Fear not!  In this section, we'll show you how to turn off the logs and let your chatbot's brilliance shine without unnecessary distractions.</p>"},{"location":"200/chatbot-rulesets/04_hide_the_logs/#goal","title":"Goal","text":"<p>After completing this section, you'll be able to enjoy clean and clutter-free conversations with your chatbot by disabling the logs.</p>"},{"location":"200/chatbot-rulesets/04_hide_the_logs/#logging-utility","title":"Logging Utility","text":""},{"location":"200/chatbot-rulesets/04_hide_the_logs/#import","title":"Import","text":"<p>We'll begin by importing the logging library, which will give us the power to control the verbosity of our chatbot's output. Add the following import statement to your code:</p> <pre><code>import logging\n</code></pre> <p>Now we're ready to silence those logs and enjoy the tranquility of clean output.</p>"},{"location":"200/chatbot-rulesets/04_hide_the_logs/#add-to-agent","title":"Add to Agent","text":"<p>It's time to modify our agent to quiet those logs and allow our chatbot's brilliance to shine through. Adjust the code where the agent is created, like so:</p> <pre><code># Create the agent\nagent = Agent(\nlogger_level=logging.ERROR\n)\n</code></pre> <p>By specifying <code>logger_level=logging.ERROR</code>, we indicate that we only want to receive logs of the highest priority, suppressing the informational logs and leaving us with a cleaner output.</p> <p>Here is the code with the new lines highlighted:</p> <pre><code>from dotenv import load_dotenv\nimport logging                     \n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\n# Load environment variables\nload_dotenv()\n# Create the agent\nagent = Agent(\nlogger_level=logging.ERROR      \n)\n# Run the agent\nChat(agent).start()\n</code></pre>"},{"location":"200/chatbot-rulesets/04_hide_the_logs/#give-it-a-try","title":"Give it a try","text":"<p>Go ahead and execute the script and have a chat.</p> <pre><code>Q: Give me a haiku about python skateboarders\nprocessing...\nA: Python skateboarders\nGlide on wheels, swift and free\nThrilling tricks they show\nQ: \n</code></pre> <p>Success</p> <p>Ahh, isn't it refreshing? Now our conversations will flow seamlessly, without any distracting logs cluttering our chatbot's responses.</p>"},{"location":"200/chatbot-rulesets/04_hide_the_logs/#code-review","title":"Code Review","text":"<p>We've made valuable progress in this stage. Before proceeding, let's verify your code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging                     \n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\n# Load environment variables\nload_dotenv()\n# Create the agent\nagent = Agent(\nlogger_level=logging.ERROR      \n)\n# Run the agent\nChat(agent).start()\n</code></pre>"},{"location":"200/chatbot-rulesets/04_hide_the_logs/#next-steps","title":"Next Steps","text":"<p>In the next section: Personality With Rulesets, we'll unlock the true potential of your chatbot by giving it a vibrant personality with the help of Rulesets. Prepare to witness your chatbot's transformation as it takes on unique traits, behaviors, and even multiple personas. </p>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/","title":"Personality","text":"<p>In our quest to create an extraordinary chatbot, we've arrived at a crucial moment: giving our agent a vibrant personality! With Griptape's Rules and Rulesets, we can define a set of rules that shape our chatbot's behavior, transforming it into a unique and charming character.</p> <p>Because I live in New Zealand, I've decided to give the chatbot a bit of a Kiwi personality - feel free to use whatever persona makes you happy.</p>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#goal","title":"Goal","text":"<p>After completing this section, you'll be able to infuse your chatbot with a delightful Kiwi (or other) personality using Griptape's Rules and Rulesets.</p>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#rules-and-rulesets","title":"Rules and Rulesets","text":""},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#importing","title":"Importing","text":"<p>To give your agent access to the <code>Rule</code> and <code>Ruleset</code> classes, we need to adjust our script to import them.</p> <p>Add the following line to the top of your script:</p> <pre><code>from griptape.rules import Rule, Ruleset\n</code></pre>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#rules","title":"Rules","text":"<p>Rules are the building blocks of our chatbot's personality. They allow us to define specific behaviors and traits. Each rule is typically focused on one important statement or characteristic. For example, we can create rules like:</p> <pre><code>Rule(\"You are an incredibly helpful kiwi tour guide.\")\nRule(\"You often forget where you kept your keys.\")\nRule(\"You speak in riddles, but not very clever ones.\")\n</code></pre> <p>The specific rules are really up to you, and you will most likely find yourself iterating on your rules in order to achieve the perfect output. </p>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#rulesets","title":"Rulesets","text":"<p>Once we have defined our rules, we can group them together into a <code>Ruleset</code>. A Ruleset allows us to combine related rules, creating a cohesive set of behaviors for our chatbot. In our case, we'll create a ruleset called \"kiwi\" for our kiwi-inspired friend.</p> <pre><code># Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname=\"kiwi\",\nrules=[\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\n</code></pre> <p>Here, we use the Ruleset class from the griptape.rules module. </p> <p>This class allows us to create a ruleset by specifying a <code>name</code> for the ruleset and a list of <code>rules</code> that define the desired behavior. In our case, the ruleset is named \"kiwi\" and contains two rules: one indicating the chatbot's New Zealander identity and another highlighting its strong kiwi accent.</p>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#add-to-the-agent","title":"Add to the Agent","text":"<p>With our rules and ruleset in place, it's time to create our kiwi chatbot! We'll assign the kiwi ruleset to the agent and let the magic unfold.</p> <p>We will update our instantiation of the Agent class and pass the kiwi_ruleset as a parameter to the rulesets argument. This associates the kiwi ruleset with our chatbot, infusing it with the desired kiwi personality traits. </p> <p>Info</p> <p>The Agent can handle multiple rulesets, which is why it's specified as a list. </p> <p>We'll demonstrate this in a later lesson.</p> <pre><code># Create the agent\nagent = Agent(\nrulesets=[kiwi_ruleset],  \nlogger_level=logging.ERROR\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#try-it","title":"Try it","text":"<p>Let's go ahead and chat with our chatbot. <pre><code>Q: Can you give me some kiwi slang?\nprocessing...\n\nA: Sure as, mate! Here are a few kiwi slang words and phrases for ya:\n1. Chur - It means thanks or cheers.\n2. Sweet as - It means something is good or all good.\n3. Jandals - It's what we call flip-flops.\n4. Dairy - It's a convenience store or a corner shop.\n5. Bach - It's a holiday home or a beach house.\n6. Chocka - It means something is full or crowded.\n7. Tiki tour - It means taking a scenic route or a detour.\n8. She'll be right - It means everything will be okay or no worries.\nHope that helps, bro!\n\nQ: I've heard people say \"yeah, nah\" - what does that mean?\nprocessing...\nA: Yeah, nah, that's a classic kiwi phrase! It's a way of expressing hesitation or disagreement. When someone says \"yeah, nah,\" it usually means they understand what you're saying, but they don't fully agree or they're not entirely convinced. It's a bit hard to explain, but you'll catch on to it when you're in New Zealand. It's just one of those quirky kiwi expressions!\n</code></pre></p> <p>Success</p> <p>Congratulations! You now have an extremely interesting chatbot!</p>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#code-review","title":"Code Review","text":"<p>We've delved into a key concept in this stage, and it's time to validate your understanding. Compare your code with the latest version.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.utils import Chat\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\n# Create the agent\nagent = Agent(\nrulesets=[\nkiwi_ruleset\n],\nlogger_level=logging.ERROR\n)\n# Run the agent\nChat(agent).start()\n</code></pre>"},{"location":"200/chatbot-rulesets/05_personality_with_rulesets/#next-steps","title":"Next Steps","text":"<p>In the next section: Custom Chat, we'll explore how to take charge of the way your chatbot behaves, by creating a custom chat function. </p>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/","title":"Custom Chat","text":"<p>While the chatbot is working, it's not very user-friendly yet. The <code>Q:</code> and <code>A:</code> prompts don't make for the most engaging for a user experience.</p> <p>In this step, we'll implement a manual chat experience, giving us more control over the conversation with our chatbot. We'll remove the Chat utility and create our own custom functions to facilitate interactive and dynamic conversations.</p> <p>Let's get started!</p>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#remove-the-chat-utility","title":"Remove the Chat Utility","text":"<p>To implement our custom manual chat functionality, we'll remove the dependency on the Chat utility provided by Griptape. We'll no longer need the line <code>from griptape.utils import Chat</code> in our code.</p> <p>Update the code by commenting out or removing the following line:</p> <pre><code># from griptape.utils import Chat\n</code></pre> <p>Don't forget to remove or comment out the line where we use the Chat utility with the agent at the bottom of the script:</p> <pre><code># Run the agent\n# Chat(agent).start()\n</code></pre> <p>With the Chat utility out of the picture, we're ready to take charge and create our own chat function.</p>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#create-our-chat","title":"Create our Chat","text":""},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#the-loop","title":"The Loop","text":"<p>Now that the old Chat function has been removed, we'll need to replace it with our own code. Let's start by with a simple loop that takes the user input until they type <code>exit</code>.</p> <pre><code># Keep track of when we're chatting\nis_chatting = True\nwhile is_chatting: # While chatting is still true\nuser_input = input(\"Chat with kiwi: \")\nif user_input == \"exit\":\nis_chatting = False\nelse:\nprint(f\"Kiwi: Hah! you said: {user_input}!\")\n</code></pre> <p>If you just run this code on it's own, you'll see that it allows the user to keep entering information over and over again until they type exit.</p> <p>It's not very amazing, and certainly doesn't interact with the agent yet, so let's modify the code to handle that.</p>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#add-the-agent","title":"Add the Agent","text":"<p>After the <code>else:</code> statement, change the code to call <code>agent.run()</code>:</p> <pre><code>while is_chatting:\n# ... truncated for brevity ... #\nelse:\nagent_result = agent.run(user_input)\nprint (f\"Kiwi: {agent_result.output.value}\")\n</code></pre> <p>As you can see now, the agent runs, and we get the output stored in the variable agent_result. We can then print that output by using the <code>output.value</code> attribute.</p>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#chat-function","title":"Chat Function","text":""},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#create","title":"Create","text":"<p>Let's clean this up a bit and define a custom <code>chat</code> function that will hold all this code instead of placing it at the end of our script.</p> <p>Here's the code for the <code>chat</code> function and the way we can call it:</p> <pre><code># Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_result = input(\"Chat with Kiwi: \")\nif user_result == \"exit\":\nis_chatting = False\nelse:           \n# Keep on chatting\nagent_result = agent.run(user_input)\nprint (f\"Kiwi: {agent_result.output.value}\")\n</code></pre>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#call","title":"Call","text":"<p>Once the chat function has been created, we can just call it and pass the agent. <pre><code># Run the agent\nchat(agent)\n</code></pre></p> <p>The <code>chat</code> function takes the <code>agent</code> as an argument.</p> <p>You shouldn't notice any difference to how you ran this before, it's just a bit cleaner.</p> <p>Engage in stimulating conversations, explore various topics, and enjoy the interactive experience as you communicate with your chatbot.</p>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#code-checkpoint","title":"Code Checkpoint","text":"<p>We made a lot of important changes in this stage. Before we move forward, let's compare code. Changed lines are highlighted.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\n# Create the agent\nagent = Agent(\nrulesets=[\nkiwi_ruleset,\n],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nif user_input == \"exit\":\nis_chatting = False\nelse:\n# Keep on chatting\nagent_result = agent.run(user_input)\nprint (f\"Kiwi: {agent_result.output.value}\")\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/06_adding_manual_chat/#next-steps","title":"Next Steps","text":"<p>Congratulations on implementing manual chat functionality and taking control of the conversation! In the next section Manners Maketh the Bot, we'll give the bot some manners and create our own Agent class to make working with the agent more consistent.</p>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/","title":"Manners Maketh the Bot","text":"<p>This course covers two topics:</p> <ul> <li>Adding manners</li> <li>Making agent interaction more consistent by creating a <code>respond</code> method</li> </ul> <p>We'll start with manners, as that will clearly demonstrate our need to find a way to make our interaction with our agent more consistent.</p>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#manners","title":"Manners","text":""},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#chatbot-can-you-hear-me","title":"Chatbot can you hear me?","text":"<p>It's always awkward to walk into the middle of a conversation and not have someone acknowledge your presence. Let's modify the code to have the chatbot introduce itself before you begin talking.</p> <p>Add a call to the agent to introduce itself before the <code># Run the agent</code> line:</p> <pre><code># Introduce the agent\nagent_response = agent.run(\"Introduce yourself to the user.\")\nprint(f\"Kiwi: {agent_response.value.output}\")\n# Run the agent\nchat(agent)\n</code></pre> <p>Now feel free to run the chat a few times. </p> <pre><code>Kiwi: Kia ora! G'day mate! I'm a conversational bot from Aotearoa, also known as New Zealand. How can I help you today?\n\nChat with the kiwi: Can I have a funny haiku about gumboots?\n\nKiwi:  Sure as, bro! Here's a funny haiku about gumboots:\nGumboots on my feet,\nSquishy mud, they can't be beat,\nKiwi fashion feat!\n</code></pre>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#repeating-ourselves","title":"Repeating ourselves","text":"<p>Just like it's not polite to ignore someone when they walk into a conversation, it's not great to repeat yourself over and over.</p> <p>Notice we're doing exactly that at the moment. </p> <pre><code># ...\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nif user_input == \"exit\":\nis_chatting = False\nelse:\n# Keep on chatting\nagent_result = agent.run(user_input)\nprint (f\"Kiwi: {agent_result.output.value}\")\n# Introduce the agent\nagent_response = agent.run(\"Introduce yourself to the user.\")\nprint(f\"Kiwi: {agent_response.value.output}\")\n# Run the agent\nchat(agent)\n</code></pre> <p>This is not a great programming practice because it means any changes we want to make to the output of our chat will have to be done in multiple places. It make maintaining the code way more difficult, and it doens't adhere to the DRY principle (Don't Repeat Yourself).</p> <p>There are a numbmer of ways we could approach this, including:</p> <ul> <li>Create a <code>respond</code> function</li> <li>Subclass the Agent and create a <code>respond</code> method.</li> </ul> <p>Both are valid solutions and it's worth looking at what it would feel like to work with each of them to see what feels best.</p> FunctionMethod <pre><code># Send a command to the agent\nagent.run(\"Can I have a haiku?\")\n# Run a command and print the result to the user\nrespond(agent, \"Can I have a haiku?\")\n</code></pre> <pre><code># Send a command to the agent\nagent.run(\"Can I have a haiku?\")\n# Run a command and print the result to the user\nagent.respond(\"Can I have a haiku?\")\n</code></pre> <p>Taking a look at both options, I think in the end it feels more consistent to use a method instead of a function due to the consistent feel of working with the agent: <code>agent.run()</code> and <code>agent.respond()</code>.</p>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#adding-the-method","title":"Adding the Method","text":""},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#subclass-the-agent","title":"Subclass the Agent","text":"<p>First we'll need to create a subclass for the Agent. This will allow us to create additional methods for the agent, and still inherit all the wonderful things Agent gives us.</p> <p>Add the following lines before <code>agent = Agent()</code> in your code:</p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\n# Create the agent\n</code></pre>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#the-respond-method","title":"The <code>Respond</code> Method","text":"<p>Now, add the respond method to the MyAgent class and use the same agent_response = agent.run and print commands you used earlier. </p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\nprint(f\"Kiwi: {agent_response.output.value}\") \n</code></pre>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#update-agent","title":"Update Agent","text":"<p>Next, replace the line where you create the agent:</p> <pre><code>agent = Agent()\n</code></pre> <p>with</p> <pre><code>agent = MyAgent()\n</code></pre> <p>to make sure we're now calling the new agent.</p>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#update-calls-to-agent-response","title":"Update calls to agent response","text":"<p>Finally, replace the lines where we were previously getting the result of the <code>agent.run()</code> function with <code>agent.respond()</code>. At the moment this will be in two locations:</p> <ul> <li>Inside the <code>chat</code> function</li> <li>When the agent introduces itself</li> </ul> <p>Replace: <pre><code>agent_result = agent.run(user_input)\nprint(f\"Kiwi: {agent_result.output.value}\")\n</code></pre></p> <p>with:</p> <pre><code>agent.respond(user_input)\n</code></pre> <p>Warning</p> <p>Don't replace those lines inside the <code>respond</code> method. Only replace them outside the method.</p>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#review","title":"Review","text":"<p>Since we just made some big changes, here are those alterations brought together, with new lines highlighted.</p> <pre><code># ...\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\nprint(f\"Kiwi: {agent_response.output.value}\")\n# ... truncated for brevity\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nif user_input == \"exit\":\nis_chatting = False\nelse:\nagent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n# ...\n</code></pre>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#more-manners","title":"More Manners","text":""},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#dont-leave-without-saying-goodbye","title":"Don't leave without saying Goodbye","text":"<p>Let's give the chatbot a bit more social grace and have it say goodbye when the person stops the chat. Before setting <code>is_chatting = False</code>, add the following line:</p> <p><pre><code>agent.respond(\"The user is finished chatting. Say goodbye.\")\n</code></pre> This will tell the agent that the user is leaving the chat, and then print the output to the screen. Here's that section of the code in context:</p> <p>Here's an example of how that would play out: <pre><code>Chat with kiwi: exit\nKiwi: Good on ya, mate! Take care and have a ripper day!\n</code></pre></p>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#clean-up-the-output","title":"Clean up the output","text":"<p>Finally, let's enhance the readability of the chat by adding a bit more space around the output of the chat.</p> <p>This can be done by modifying the <code>resopnd</code> method to add two print statements.</p> <pre><code>class MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\nprint(\"\")\nprint(f\"Kiwi: {agent_response.output.value}\")\nprint(\"\")\n</code></pre>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#code-checkpoint","title":"Code Checkpoint","text":"<p>We made some major updates to the code in this section. Take a look:</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\nprint(\"\")\nprint(f\"Kiwi: {agent_response.output.value}\")\nprint(\"\")\n# Create the agent\nagent = MyAgent(\nrulesets=[\nkiwi_ruleset,\n],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nif user_input == \"exit\":\nagent.respond(\"The user is finished chatting. Say goodbye.\")\nis_chatting = False\nelse:\nagent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/07_manners_maketh_the_bot/#next-steps","title":"Next Steps","text":"<p>Congratulations on implementing manual chat functionality and taking control of the conversation! In the next section Adding Another Ruleset, we'll explore the world of output rulesets, unlocking the ability to control the chatbot's responses in different formats such as JSON, YAML, or even haiku.</p>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/","title":"Rulesets for Output","text":"<p>Consider a situation where we have integrated the LLM (Language Learning Module) into our code. It becomes crucial for us to receive the output in a specific format that aligns with our requirements, like JSON. By employing an output ruleset, we can precisely control the structure and format of the chatbot's responses.</p>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#goal","title":"Goal","text":"<p>After completing this section, you'll be able use output rulesets to get responses from the LLM in the way most useful for your application.</p>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#new-ruleset","title":"New Ruleset","text":""},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#json-ruleset","title":"JSON Ruleset","text":"<p>To achieve our goal of formatting the response as JSON, we'll create a ruleset called \"json_ruleset.\" This ruleset will contain a single rule that tells the chatbot to use JSON when formulating it's response. Place it after the kiwi_rulesest:</p> <pre><code>json_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Use JSON when formulating your response.\")\n]\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#integration","title":"Integration","text":"<p>With the json_ruleset in hand, it's time to integrate it into our Agent. By including it in the list of rulesets available to the Agent, we can harness its power to control the response format.</p> <pre><code># Create the agent\nagent = MyAgent(\nrulesets=[kiwi_ruleset, json_ruleset],\nlogger_level=logging.ERROR\n)\n</code></pre> <p>Here, we modify the <code>MyAgent</code> instantiation to include both the <code>kiwi_ruleset</code> and <code>json_ruleset</code> in the <code>rulesets=[]</code> argument. This ensures that our chatbot possesses the kiwi personality traits while also adhering to the desired response format specified by the json_ruleset.</p>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#test","title":"Test","text":"<p>Prepare for an exciting conversation as we engage our chatbot in a quest for knowledge about Wellington's top tourist destinations. Let's dive in:</p> <pre><code>Q: \"Hey chatbot, what are the top three tourist destinations in Wellington? Can you give me a name and a description?\"\nKiwi: {\n\"message\": \"Absolutely, mate! Here are the top three tourist destinations in Wellington with a brief description:\",\n\"destinations\": [\n{\n\"name\": \"Te Papa Museum\",\n\"description\": \"New Zealand's national museum, known for its interactive and innovative exhibits.\"\n},\n{\n\"name\": \"Wellington Cable Car\",\n\"description\": \"An iconic Wellington attraction, offering stunning views of the city and harbour.\"\n},\n{\n\"name\": \"Zealandia Ecosanctuary\",\n\"description\": \"A unique protected natural area where you can see New Zealand's wildlife up close.\"\n}\n]\n}\n</code></pre> <p>Enjoy the beauty of Wellington's top tourist destinations, neatly presented in a JSON format, as our chatbot provides you with insightful reasons to visit each destination.</p>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#using-it","title":"Using it","text":""},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#adding-keys","title":"Adding Keys","text":"<p>While this is an interesting example, let's use the ruleset in a way that helps control the way our application works.</p> <p>Currently, the user has to know to type \"exit\" to leave the chat. This is not a great user experience, as it's a hidden command. We are using a chat-interface... wouldn't it be great if we could simply tell the chatbot when we were done chatting and it would quit on it's own?</p> <p>Turns out, we can do just that - by using the <code>json_ruleset</code>.</p> <p>Modify the json ruleset to look like the following:</p> <pre><code>json_ruleset = Ruleset(\nname='json_ruleset',\nrules = [\nRule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\nRule(\"The 'response' value should be a string that is your response to the user.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n</code></pre> <p>The first rule tells the chatbot to respond in json, and specifies the keys. </p> <p>The second and third rules explain what the values for those keys should be. Notice the third one specifically says that if it sounds like the person is done chatting, set <code>continue_chatting</code> to <code>False</code>.</p> <p>Go ahead and run the example and notice the response.</p> <pre><code>Kiwi: {\n\"response\": \"G'day mate! I'm a bot from New Zealand, speaking with a strong kiwi accent. How can I assist you today?\",\n\"continue_chatting\": true\n}\nChat with Kiwi: see ya later\nKiwi: {\n\"response\": \"No worries, mate! Catch ya later!\",\n\"continue_chatting\": false\n}\n</code></pre> <p>See how <code>continue_chatting</code> returns false when it sounds like we're done talking?</p> <p>Let's now use this json output!</p>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#import-json","title":"Import JSON","text":"<p>First, we'll have to import the json library. To do that, add the following at the beginning of your script:</p> <pre><code>import json\n</code></pre>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#load-json","title":"Load JSON","text":"<p>Next, we'll use the <code>json.loads()</code> function to take the output from the agent's response and convert it into json data.</p> <p>Modify the start of the <code>respond</code> method of the <code>MyAgent</code> class, to look like:</p> <p><pre><code>    # ... truncated for brevity\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\n#...\n</code></pre> This creates two variables - <code>response</code> which will be the normal response from the chatobt, and <code>continue_chatting</code> which should be <code>True</code> or <code>False</code>.</p>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#update-print","title":"Update Print","text":"<p>Modify the print statement where we get the response from the chatbot to look like:</p> <pre><code>        print(f\"Kiwi: {response}\")\n</code></pre>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#return-state","title":"Return State","text":"<p>And then return the <code>continue_chatting</code> at the end of the method. <pre><code>    # ...\ndef respond (self, user_input):\n# ...\nreturn continue_chatting\n#...\n</code></pre></p> <p>The whole class should look like:</p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nprint(\"\")\nprint(f\"Kiwi: {response}\")\nprint(\"\")\nreturn continue_chatting\n</code></pre>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#simplify-chat","title":"Simplify Chat","text":"<p>Since we're returning <code>True</code> or <code>False</code> from the <code>agent.respond()</code> method, the entire <code>chat</code> function can now be simplified as: <pre><code># Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nis_chatting = agent.respond(user_input)\n</code></pre></p> <p>Give it a try and see how you can quit the chat simply by holding the conversation:</p> <pre><code>Kiwi: G'day mate! I'm a bot from New Zealand, speaking with a strong kiwi accent. How can I assist you today?\n\nChat with Kiwi: I'm good, how are you?\n\nKiwi: I'm doing great, thanks for asking! Anything else you'd like to chat about, mate?\n\nChat with Kiwi: Nah, I'm done for today.\n\nKiwi: No worries, mate! Have a good one. Don't hesitate to reach out if you need anything else.\n</code></pre>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#code-review","title":"Code Review","text":"<p>By leveraging the power of output rulesets, we've demonstrated how you can guide your chatbot to deliver responses in any desired format. Take a moment to check your code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n# Griptape Items\nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\njson_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\nRule(\"The 'response' value should be a string that is your response to the user.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nprint(\"\")\nprint(f\"Kiwi: {response}\")\nprint(\"\")\nreturn continue_chatting\n# Create the agent\nagent = MyAgent(\nrulesets=[kiwi_ruleset, json_ruleset],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nis_chatting = agent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/08_adding_another_ruleset_for_output/#next-steps","title":"Next Steps","text":"<p>In the next stage, Formatting Chat Output,   we'll make the chat interface more visually appealing and chat-like using the rich library. Get ready to add some style and flair to your conversations!</p>"},{"location":"200/chatbot-rulesets/09_formatting_chat_output/","title":"Formatting Output","text":""},{"location":"200/chatbot-rulesets/09_formatting_chat_output/#rich-library","title":"Rich Library","text":"<p>To make the chatbot output look more chat-like, we'll use the <code>rich</code> library. This library provides advanced formatting and styling options for the console output. We'll modify the chatbot function to apply formatting to the agent's responses. </p>"},{"location":"200/chatbot-rulesets/09_formatting_chat_output/#import","title":"Import","text":"<p>First, let's update the code to import the <code>rich</code> library. Include the following import statements in the import section of <code>app.py</code>.</p> <pre><code>from rich import print as rprint\nfrom rich.panel import Panel\n</code></pre> <p>The first line imports the <code>print</code> library from <code>rich</code> and assigns an alias: <code>rprint</code>. By using <code>rprint</code> as an alias, we can replace regular <code>print</code> statements in our code with <code>rprint</code> to utilize the enhanced capabilities of 'rich' for displaying formatted text.</p> <p>For example, instead of using <code>print(\"Hello, World!\")</code>, we can now use <code>rprint(\"Hello, World!\")</code> to leverage the formatting capabilities provided by 'rich' when displaying the output.</p> <p>Tip</p> <p>Sometimes people will simply recommend overiding the standard print functionality by doing <code>from rich import print</code>, but that would actually replace other uses of <code>print</code> in your code. For this reason, I recommend importing it as <code>rprint</code> in order to ensure behavior we expect. But in reality, it's totally up to you. Read the documentation for more information.</p> <p>The second line imports the Panel class from the <code>rich.panel</code> module. The Panel class represents a styled container that can be used to encapsulate and visually enhance content within a console output. It allows us to create panels with various styles, colors, and borders.</p>"},{"location":"200/chatbot-rulesets/09_formatting_chat_output/#panel","title":"Panel","text":"<p>Next, we'll update our <code>respond</code> method to use the new <code>rprint</code> alias and the <code>Panel</code> class. This is a pretty simple change to start with, but you'll very quickly see how much nicer things look.</p> <p>Inside the <code>respond</code> method, replace the line that looks like:</p> <p><pre><code>print(f\"Kiwi: {response}\")\n</code></pre> with</p> <pre><code>rprint(Panel(f\"Kiwi: {response}\"))\n</code></pre> <p>As you can see, we've simply replaced <code>print</code> with <code>rprint</code>, and wrapped the string that was being submitted with <code>Panel()</code>.</p> <p>If you run this code you'll see a quick improvement. <pre><code>\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Kia Ora! What can I do for you today?                                     \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nChat with Kiwi: \n</code></pre></p> <p>Much better, right? We're not done yet..</p>"},{"location":"200/chatbot-rulesets/09_formatting_chat_output/#fitting-it-in","title":"Fitting it in","text":"<p>One of the nice things about <code>rich</code> is that it can control the width of the Panel automatically by using a <code>fit</code> function to fit the content.</p> <p>Modify the <code>Panel</code> line to include <code>.fit</code> <pre><code>rprint(Panel.fit(f\"Kiwi: {response}\"))\n</code></pre></p> <p>Try it out to see how it feels.</p> <pre><code>Chat with Kiwi: Say hello in 2 words as a kiwi\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Kia ora, mate! \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"200/chatbot-rulesets/09_formatting_chat_output/#propper-width","title":"Propper width","text":"<p>Sometimes the response can be quite long and fill the terminal. In these cases, it's nice to also be able to give a maximum width to your reponse. You can do this by giving the <code>width</code> attribute. Used in combination with <code>fit</code>, the panel will be either the width of your content, or the width you specify with the attribute - whatever is smaller.</p> <p>Modify the prompt:</p> <pre><code>rprint(Panel.fit(f\"Kiwi: {response}\", width=80))\n</code></pre> <p>Now the panel will be at most 80 characters wide.</p> <pre><code>Chat with Kiwi: What's the best thing about the Wairarapa?\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Oh, the Wairarapa, mate! It's a stunner. The best thing about it has   \u2502\n\u2502 to be the beautiful landscapes, from the rugged coastlines to the lush       \u2502\n\u2502 vineyards. It's a real treat for the eyes, I tell ya!                        \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"200/chatbot-rulesets/09_formatting_chat_output/#code-review","title":"Code Review","text":"<p>As you can see, this has already helped our readability a ton. Compare your code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\njson_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\nRule(\"The 'response' value should be a string that is your response to the user.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nprint(\"\")\nrprint(Panel.fit(f\"Kiwi: {response}\", width=80))\nprint(\"\")\nreturn continue_chatting\n# Create the agent\nagent = MyAgent(\nrulesets=[kiwi_ruleset, json_ruleset],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nis_chatting = agent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/09_formatting_chat_output/#next-steps","title":"Next Steps","text":"<p>As a developer, you may be intersted in having your chatbot write code for you, or create some tables. In the next section: Markdown Madness, we'll take a look at the <code>Markdown</code> class in <code>rich</code>, and use it to ensure output looks as we expect.</p>"},{"location":"200/chatbot-rulesets/10_markdown_madness/","title":"Markdown Madness","text":"<p>In this stage, we'll enhance our chatbot's code display by harnessing the power of Markdown. With Markdown, we can beautifully format and highlight code snippets to make them more readable and visually appealing. </p>"},{"location":"200/chatbot-rulesets/10_markdown_madness/#review","title":"Review","text":"<p>First let's see why our current output doesn't work. Ask the chatbot to do something useful - like create a bash script that will create an alias to launch VS Code.</p> <pre><code>Chat with Kiwi: Can you create a bash script that will create an \nalias for me to launch visual studio code?\n\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 Kiwi: Kia ora! G'day mate! I can definitely help you with that. Here's a     \u2502\n\u2502 bash script that will create an alias for you to launch Visual Studio Code:  \u2502\n\u2502                                                                              \u2502\n\u2502 ```bash                                                                      \u2502\n\u2502 #!/bin/bash                                                                  \u2502\n\u2502                                                                              \u2502\n\u2502 echo \"alias code='open -a Visual\\ Studio\\ Code'\" &gt;&gt; ~/.bash_profile          \u2502\n\u2502 source ~/.bash_profile                                                       \u2502\n\u2502                                                                              \u2502\n\u2502 echo \"Alias created! You can now launch Visual Studio Code by typing 'code'  \u2502\n\u2502 in your terminal. Let me know if you need any further assistance!\"           \u2502\n\u2502 ```                                                                          \u2502\n\u2502                                                                              \u2502\n\u2502 Just copy and paste this script into a new file, save it with a `.sh`        \u2502\n\u2502 extension (e.g., `create_alias.sh`), and then run it in your terminal using  \u2502\n\u2502 `bash create_alias.sh`. Let me know if you have any questions or need        \u2502\n\u2502 further help!                                                                \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>As you can see, the script is fine, but it doesn't look like a script. It looks like something you'd enter in a Markdown file that you'd expect to eventually be rendered as a script. We're going to make this look much nicer.</p>"},{"location":"200/chatbot-rulesets/10_markdown_madness/#markdown","title":"Markdown","text":""},{"location":"200/chatbot-rulesets/10_markdown_madness/#import","title":"Import","text":"<p>To get started, we need to update our imports by adding the <code>Markdown</code> class.</p> <pre><code>from rich.markdown import Markdown\n</code></pre> <p>The <code>Markdown</code> class for the <code>rich</code> library allows for rendering formatted Markdown text.</p>"},{"location":"200/chatbot-rulesets/10_markdown_madness/#using-it","title":"Using it","text":"<p>Next, we'll modify the <code>respond</code> method to use the <code>Markdown</code> class. There are a few things we'll need to do. First, we'll take the output of the chatbot's response and convert it into a formatted Markdown text using the following line:</p> <pre><code>        # ...\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nformatted_response = Markdown(response)\n# ...\n</code></pre> <p>Then, we'll replace our <code>rprint</code> statement in the panel to use the <code>formatted_reponse</code> instead of the string we were sending earlier.</p> <pre><code>        # ...\nrprint(Panel.fit(formatted_response, width=80))\n# ...\n</code></pre> <p>Warning</p> <p>Make sure you don't do something like <code>rprint(Panel.fit(f\"Kiwi : {formatted_response}\", width=80))</code> because it will print out the object, not the data. </p> <p>Here's the new <code>respond</code> method in it's entirety:</p> <pre><code># Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = self.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nformatted_response = Markdown(response)\nrprint(\"\")\nrprint(Panel.fit(formatted_response, width=80))\nrprint(\"\")\nreturn continue_chatting\n</code></pre>"},{"location":"200/chatbot-rulesets/10_markdown_madness/#update-ruleset","title":"Update Ruleset","text":"<p>Finally, we'll change our <code>json_ruleset</code> to ensure the response works with Markdown.</p> <p>Modify the second rule in the <code>json_ruleset</code> so it specifies the response should be able to be safely converted into markdown format.</p> <p><pre><code>        # ... previous code\nRule(\"The 'response' value should be a string that can be safely converted to markdown format. Include line returns when necessary.\"),\n# ...\n</code></pre> And the result. I've added a screenshot so you can see how much better it looks.</p> <p></p> <p>To see the enhanced code display in action, run your chatbot and observe the beautifully formatted code snippets that were previously plain text. Try creating tables, csv files, python, tasks lists, etc. Enjoy the new level of elegance and readability brought by Markdown magic!</p>"},{"location":"200/chatbot-rulesets/10_markdown_madness/#code-checkpoint","title":"Code Checkpoint","text":"<p>Before moving forward, make sure your code works as expected.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\njson_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\nRule(\"The 'response' value should be a string that is your response to the user.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nrprint(\"\")\nrprint(Panel.fit(f\"Kiwi: {response}\", width=80))\nrprint(\"\")\nreturn continue_chatting\n# Create the agent\nagent = MyAgent(\nrulesets=[kiwi_ruleset, json_ruleset],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = input(\"Chat with Kiwi: \")\nis_chatting = agent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/10_markdown_madness/#next-steps","title":"Next Steps","text":"<p>In the next section, Improving the Prompt, we'll continue making things better by improving the appearance of the prompt.</p>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/","title":"Improving the Prompt","text":"<p>In this stage, we'll improve the chatbot experience by using colors with the <code>rich</code> library. This will allow us to distinguish the chatbot's response from our prompt.</p>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#style-class","title":"Style Class","text":"<p>To add colors, we'll take advantage of the <code>Style</code> class from the <code>rich</code> library. This class allows you to use one of the 256 Standard Colors that are accepted in terminals, Hex values, or RGB values. It's pretty nice.</p>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#import","title":"Import","text":"<p>To add it, update the <code>import</code> section of your code to include the <code>Style</code> class:</p> <pre><code>from rich.style import Style\n</code></pre>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#color","title":"Color","text":"<p>Let's demonstrate how this works by updating our <code>respond</code> method to add some color.</p> <p>Change the <code>rprint</code> line to include the <code>style</code> attribute:</p> <p><pre><code>class MyAgent(Agent):\ndef chatbot(agent, user_input):\n# ...\nrprint(Panel.fit(formatted_response, \nwidth=80, \nstyle=Style(color=\"light_sea_green\")\n))\n# ...\n</code></pre> Let's see how it looks:</p> <p></p>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#prompt-class","title":"Prompt Class","text":"<p>We can also take advantage of a <code>Prompt</code> class in the <code>rich</code> library to make our prompt a bit nicer to look at by separating the color of the prompt from the text the user enters.</p>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#import_1","title":"Import","text":"<p>First, import the Prompt class:</p> <pre><code>from rich.prompt import Prompt\n</code></pre>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#prompt","title":"Prompt","text":"<p>Then, change the <code>input</code> line in the <code>chat</code> function to use the <code>Prompt.ask()</code> function:</p> <pre><code>def chat(agent):\n# ...\nuser_input = Prompt.ask(\"[grey50]Chat with Kiwi:\")\n# ...\n</code></pre> <p>In this updated code, we replace the standard <code>input</code> function with <code>Prompt.ask()</code> and pass it a color to create an improved prompt. Of course, you can choose whatever color you want to make it stand out even more. </p> <p></p> <p>There are a few interesting options with the Prompt class that are worth exploring, including default values, a list of choices, and more. Check out the documentation for more goodness.</p>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#try-it","title":"Try it","text":"<p>Engage in a conversation with Kiwi and enjoy the interactive and intuitive nature of the prompt. Respond to the prompt using natural language, and observe the chatbot's responses displayed in the familiar chat-like format.</p>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#code-review","title":"Code Review","text":"app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create a ruleset for the agent\nkiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\nRule(\"You identify as a New Zealander.\"),\nRule(\"You have a strong kiwi accent.\")\n]\n)\njson_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\nRule(\"The 'response' value should be a string that can be safely converted to markdown format.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nformatted_response = Markdown(response)\nprint(\"\")\nrprint(Panel.fit(formatted_response, \nwidth=80, \nstyle=Style(color=\"light_sea_green\")\n))\nprint(\"\")\nreturn continue_chatting\n# Create the agent\nagent = MyAgent(\nrulesets=[kiwi_ruleset, json_ruleset],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = Prompt.ask(\"[grey50]Chat with Kiwi:\")\nis_chatting = agent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself to the user.\")\n# Run the agent\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/11_gleaming_the_chat/#next-steps","title":"Next Steps","text":"<p>In the next section, Multiple Personas, we'll dive into an explosion of personality by using Rulesets to create multiple personas to chat with.</p>"},{"location":"200/chatbot-rulesets/12_multiple_personas/","title":"Multiple Personas","text":"<p>In this exciting stage, we're going to give our chatbot multiple personalities to make conversations even more dynamic and engaging. Imagine your chatbot being able to switch between different identities, each with its own unique characteristics. Let's get started!</p>"},{"location":"200/chatbot-rulesets/12_multiple_personas/#rulesets","title":"Rulesets","text":""},{"location":"200/chatbot-rulesets/12_multiple_personas/#creating-personas","title":"Creating Personas","text":"<p>To give our chatbot multiple personas, we'll create separate rulesets for each identity. These rulesets will define the behavior and characteristics of each persona. Here, I've added two new rulesets: \"Zelda\" (my grandmother), and \"Dad\" (my dad). </p> <pre><code># Create rulesets for each persona\nkiwi_ruleset = Ruleset(\nname='Kiwi',\nrules=[\nRule('You identify only as a New Zealander.'),\nRule('You have a very strong Kiwi accent.')\n]\n)\nzelda_ruleset = Ruleset(\nname='Zelda',\nrules=[\nRule('You identify only as a grandmother.'),\nRule('You like to use Yiddish.')\n]\n)\ndad_ruleset = Ruleset(\nname='Dad',\nrules=[\nRule('You identify only as a dad.'),\nRule('You like to use dad jokes.')\n]\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/12_multiple_personas/#switching-personas","title":"Switching Personas","text":"<p>We can't just give the chatbot all these personas and expect it to know what to do. We need to provide some structure around it. So we're going to create another ruleset called the Switcher. This ruleset will understand how and when to switch personalities. There are some key rules for us to think of:</p> <ul> <li>We want the chatbot to be able to switch personalities when it makes sense to (either it thinks it needs to, or the user asks for it)</li> <li>We don't want it to identify as the \"Switcher\" or \"json_output\" rulesets. That wouldn't make any sense.</li> <li>When it does switch rulesets, it should only take on the new persona</li> <li>When it switches personas, it should remember the facts from the previous conversation, but not act like the previous identity.</li> </ul> <pre><code>switcher_ruleset = Ruleset(\nname='Switcher',\nrules=[\nRule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\nRule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\nRule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\nRule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n]\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/12_multiple_personas/#add-the-rulesets","title":"Add the Rulesets","text":"<p>Let's now give the agent all these rulesets to work with. We'll simply add them to the list of <code>rulesets</code> in the <code>agent</code> instantiation.</p> <pre><code># Create the agent\nagent = MyAgent(\nrulesets=[\nkiwi_ruleset, zelda_ruleset, dad_ruleset, \nswitcher_ruleset, json_ruleset\n],\nlogger_level=logging.ERROR\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/12_multiple_personas/#prompt-adjustment","title":"Prompt Adjustment","text":"<p>It doesn't make sense for us to keep prompting the user to \"Chat with Kiwi:\" if we might have multiple personalities, so let's modify the <code>Prompt</code> in the <code>chat</code> function:</p> <pre><code>def chat(agent):\n# ...\nuser_input = Prompt.ask(\"[grey50]Chat\")\n# ...\n</code></pre>"},{"location":"200/chatbot-rulesets/12_multiple_personas/#chat","title":"Chat","text":"<p>Now your chatbot is ready to switch between different personalities and engage in exciting conversations with users! Go ahead and run the chatbot. Ask it how many personalities it has, ask it to switch them up, etc. See how it performs. </p> <p></p> <p>Notice in the above image we've got two personas talking, but it's difficult to tell them apart. We'll fix that in the next section.</p>"},{"location":"200/chatbot-rulesets/12_multiple_personas/#code-review","title":"Code Review","text":"<p>We're making great progress. Review the code.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create rulesets for each persona\nkiwi_ruleset = Ruleset(\nname='Kiwi',\nrules=[\nRule('You identify only as a New Zealander.'),\nRule('You have a very strong Kiwi accent.')\n]\n)\nzelda_ruleset = Ruleset(\nname='Zelda',\nrules=[\nRule('You identify only as a grandmother.'),\nRule('You like to use Yiddish.')\n]\n)\ndad_ruleset = Ruleset(\nname='Dad',\nrules=[\nRule('You identify only as a dad.'),\nRule('You like to use dad jokes.')\n]\n)\nswitcher_ruleset = Ruleset(\nname='Switcher',\nrules=[\nRule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\nRule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\nRule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\nRule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n]\n)\njson_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: response, continue_chatting.\"),\nRule(\"The 'response' value should be a string that can be safely converted to markdown format.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\nformatted_response = Markdown(response)\nprint(\"\")\nrprint(Panel.fit(formatted_response, \nwidth=80, \nstyle=Style(color=\"light_sea_green\")\n))\nprint(\"\")\nreturn continue_chatting\n# Create the agent\nagent = MyAgent(\nrulesets=[\nkiwi_ruleset, zelda_ruleset, dad_ruleset,\nswitcher_ruleset, json_ruleset  \n],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = Prompt.ask(\"[grey50]Chat\")\nis_chatting = agent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself.\")\n# Run the agent#\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/12_multiple_personas/#next-steps","title":"Next Steps","text":"<p>In the next stage: Colorful Personalities, we'll make it easier to differentiate between which chatbot you're speaking with.</p>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/","title":"Colorful Personalities","text":"<p>In this step, we're going to add some flair to our chatbot by assigning different colors to each persona. This will visually distinguish the different personalities, making the conversation more engaging and fun! </p> <p>We'll do this by giving each persona a favorite color, then add another key to our <code>json_output</code> ruleset, and use that key in our <code>respond</code> method.</p>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#updating-rulesets","title":"Updating Rulesets","text":""},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#favorite-colors","title":"Favorite Colors","text":"<p>To assign colors to each persona, we'll add new rules to each of our identity ruleset to give them all favorite colors. You're welcome to use Standard Colors, Hex, or rgb values. Whatever makes you happy.</p> <pre><code>kiwi_ruleset = Ruleset(\nname = \"kiwi\",\nrules = [\n# ... truncated for brevity\nRule(\"Favorite color: light_sea_green\")\n]\n)\nzelda_ruleset = Ruleset(\nname=\"Zelda\",\nrules=[\n# ...\nRule(\"Favorite color: light_pink3\")\n]\n)\ndad_ruleset = Ruleset(\nname=\"Dad\",\nrules=[\n# ... \nRule(\"Favorite color: light_steel_blue\")\n]\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#add-key","title":"Add Key","text":"<p>We also need to make changes to the <code>json_ruleset</code> to include the Favorite Color key. Modify the first rule to include that key:</p> <pre><code>json_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: response, favorite_color, continue_chatting.\"),\n# ... \n]\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#respond-method","title":"Respond Method","text":"<p>Next, we'll adjust the <code>respond</code> method get the favorite color, and use it properly.</p>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#get-the-color","title":"Get the color","text":"<p>After the <code>continue_chatting = data[\"continue_chatting\"]</code> line, add one to get the color:</p> <pre><code>class MyAgent(Agent):\ndef respond(self, user_input):\n# ...\ncontinue_chatting = data[\"continue_chatting\"]\ncolor = data[\"favorite_color\"]\n# ...\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#use-it","title":"Use it","text":"<p>Then, update the <code>style</code> line in the <code>rprint</code> statement to use <code>color</code> instead of specifying it directly as we were before:</p> <pre><code>class MyAgent(Agent):\ndef respond(self, user_input):\n# ...\nrprint(Panel.fit(formatted_response, \nwidth=80, \nstyle=Style(color=color)\n))\n# ...\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#try-it","title":"Try it","text":"<p>Run the code and notice how much nicer it is to be able to discern who is talking based on their color.</p> <p></p>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#adding-a-name","title":"Adding a Name","text":"<p>We're not quite finished yet. We also can make things a bit easier to follow if we clarify the name of the persona we're chatting with.</p>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#update-ruleset","title":"Update Ruleset","text":"<p>This will be a relatively quick fix. We just need to add another key to the <code>json_ruleset</code>, and then modify the <code>rprint</code> statement again.</p> <p>First, add the <code>name</code> key:</p> <pre><code>json_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\n# ...\nRule(\"Respond in plain text only with JSON objects that have the following keys: name, response, favorite_color, continue_chatting.\"),\n# ...\n]\n)\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#get-the-name","title":"Get the Name","text":"<p>Now get the <code>name</code> from the json data in the <code>respond</code> method of the <code>MyAgent</code> class:</p> <pre><code>class MyAgent(Agent):\ndef respond(self, user_input):\n# ...\ncolor = data[\"favorite_color\"]\nname = data[\"name\"]\n# ...\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#use-it_1","title":"Use it","text":"<p>Then, add a <code>title</code> and <code>title_align</code> in the <code>rprint</code> function:</p> <pre><code>class MyAgent(Agent):\ndef respond(self, user_input):\n# ...\nrprint(Panel.fit(formatted_response, \nwidth=80, \nstyle=Style(color=color),\ntitle=name,\ntitle_align=\"left\"\n))\n# ...\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#try-it_1","title":"Try it","text":"<p>Give it a try and see how much nicer it is!</p> <p></p>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#code-review","title":"Code Review","text":"<p>Lots of changes in this section, with some great usability enhancements! </p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create rulesets for each persona\nkiwi_ruleset = Ruleset(\nname='Kiwi',\nrules=[\nRule('You identify only as a New Zealander.'),\nRule('You have a very strong Kiwi accent.'),\nRule(\"Favorite color: light_sea_green\")\n]\n)\nzelda_ruleset = Ruleset(\nname='Zelda',\nrules=[\nRule('You identify only as a grandmother.'),\nRule('You like to use Yiddish.'),\nRule(\"Favorite color: light_pink3\")\n]\n)\ndad_ruleset = Ruleset(\nname='Dad',\nrules=[\nRule('You identify only as a dad.'),\nRule('You like to use dad jokes.'),\nRule(\"Favorite color: light_steel_blue\")\n]\n)\nswitcher_ruleset = Ruleset(\nname='Switcher',\nrules=[\nRule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\nRule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\nRule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\nRule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n]\n)\njson_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: name, response, favorite_color, continue_chatting.\"),\nRule(\"The 'response' value should be a string that can be safely converted to markdown format.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nagent_response = agent.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\ncolor = data[\"favorite_color\"]\nname = data[\"name\"]\nformatted_response = Markdown(response)\nprint(\"\")\nrprint(Panel.fit(formatted_response, \nwidth=80, \nstyle=Style(color=color),\ntitle=name,\ntitle_align=\"left\"\n))\nprint(\"\")\nreturn continue_chatting\n# Create the agent\nagent = MyAgent(\nrulesets=[\nkiwi_ruleset, zelda_ruleset, dad_ruleset,\nswitcher_ruleset, json_ruleset  \n],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = Prompt.ask(\"[grey50]Chat\")\nis_chatting = agent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself.\")\n# Run the agent#\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/13_adding_personality_colors/#next-steps","title":"Next Steps","text":"<p>In the next stage: Quick Feedback, we'll make the chatbot feel a bit more responsive to user input by giving it a spinner so it doesn't feel like it's lagging while the LLM is fetching it's response.</p>"},{"location":"200/chatbot-rulesets/14_making_it_quick/","title":"Quick Feedback","text":""},{"location":"200/chatbot-rulesets/14_making_it_quick/#ux-enhancement","title":"UX Enhancement","text":"<p>The UX of our application can be enhanced by letting the user know that the application is working after they execute a command. At the moment, it is processing, but it just doesn't let the user know. We'll use the Spinner functionality from the Rich library to make the application a little more user-friendly and  visually appealing.</p>"},{"location":"200/chatbot-rulesets/14_making_it_quick/#spinner","title":"Spinner","text":"<p>The <code>Console</code> class has a <code>status</code> method which will allow us to display a <code>Spinner</code> to the user while Griptape is waiting for the LLM response.</p> <p>Abstract</p> <p>There are lots of spinners available. You can check them out by running the following in your terminal:</p> <pre><code>python -m rich.spinner\n</code></pre> <p></p>"},{"location":"200/chatbot-rulesets/14_making_it_quick/#importing-the-console","title":"Importing the Console","text":"<pre><code>from rich.console import Console\n</code></pre> <p>Importing the Console class from the <code>rich</code> library is simple and straightforward, and should be familliar to you by this point in the lesson.</p>"},{"location":"200/chatbot-rulesets/14_making_it_quick/#modify-respond","title":"Modify Respond","text":"<p>We will add a spinner to our <code>respond</code> method in the <code>MyAgent</code> subclass. This will show an animated spinner in the console while our agent is processing the user's input. This makes the app feel more responsive.</p> <p>Update the <code>respond</code> method as follows:</p> <pre><code>class MyAgent(Agent):\ndef respond(self, user_input):\nconsole = Console()\nwith console.status(spinner=\"simpleDotsScrolling\", status=\"\"):\nagent_response = self.run(user_input)\n# ...\n</code></pre> <p>In the code above, <code>console.status(spinner=\"simpleDotsScrolling\", status=\"\")</code> starts an animated spinner in the console that will run until the block of code it is wrapping (the agent's processing of user input) completes. </p> <p>Note</p> <p>We've left <code>status</code> blank - because we don't really need to send any text. However, feel free to add some text here if you desire.</p> <p>Now when you run the chat, you'll notice the animated spinner right after you ask the chatbot a question!</p> <p></p>"},{"location":"200/chatbot-rulesets/14_making_it_quick/#code-review","title":"Code Review","text":"<p>Double-check your code to make sure the spinner is working as expected.</p> app.py<pre><code>from dotenv import load_dotenv\nimport logging\nimport json\n# Rich\nfrom rich import print as rprint\nfrom rich.panel import Panel\nfrom rich.markdown import Markdown\nfrom rich.style import Style\nfrom rich.prompt import Prompt\nfrom rich.console import Console\n# Griptape \nfrom griptape.structures import Agent\nfrom griptape.rules import Rule, Ruleset\n# Load environment variables\nload_dotenv()\n# Create rulesets for each persona\nkiwi_ruleset = Ruleset(\nname='Kiwi',\nrules=[\nRule('You identify only as a New Zealander.'),\nRule('You have a very strong Kiwi accent.'),\nRule(\"Favorite color: light_sea_green\")\n]\n)\nzelda_ruleset = Ruleset(\nname='Zelda',\nrules=[\nRule('You identify only as a grandmother.'),\nRule('You like to use Yiddish.'),\nRule(\"Favorite color: light_pink3\")\n]\n)\ndad_ruleset = Ruleset(\nname='Dad',\nrules=[\nRule('You identify only as a dad.'),\nRule('You like to use dad jokes.'),\nRule(\"Favorite color: light_steel_blue\")\n]\n)\nswitcher_ruleset = Ruleset(\nname='Switcher',\nrules=[\nRule(\"IMPORTANT: you have the ability to switch identities when you find it appropriate.\"),\nRule(\"IMPORTANT: You can not identify as 'Switcher' or 'json_output'.\"),\nRule(\"IMPORTANT: When you switch identities, you only take on the persona of the new identity.\"),\nRule(\"IMPORTANT: When you switch identities, you remember the facts from your conversation, but you do not act like your old identity.\"),\n]\n)\njson_ruleset = Ruleset(\nname=\"json_ruleset\",\nrules=[\nRule(\"Respond in plain text only with JSON objects that have the following keys: name, response, favorite_color, continue_chatting.\"),\nRule(\"The 'response' value should be a string that can be safely converted to markdown format.\"),\nRule(\"If it sounds like the person is done chatting, set 'continue_chatting' to False, otherwise it is True\"),\n]\n)\n# Create a subclass for the Agent\nclass MyAgent(Agent):\ndef respond (self, user_input):\nconsole = Console()\nwith console.status(spinner=\"simpleDotsScrolling\", status=\"\"):\nagent_response = self.run(user_input)\ndata = json.loads(agent_response.output.value)\nresponse = data[\"response\"]\ncontinue_chatting = data[\"continue_chatting\"]\ncolor = data[\"favorite_color\"]\nname = data[\"name\"]\nformatted_response = Markdown(response)\nprint(\"\")\nrprint(Panel.fit(formatted_response, \nwidth=80, \nstyle=Style(color=color),\ntitle=name,\ntitle_align=\"left\"\n))\nprint(\"\")\nreturn continue_chatting\n# Create the agent\nagent = MyAgent(\nrulesets=[\nkiwi_ruleset, zelda_ruleset, dad_ruleset,\nswitcher_ruleset, json_ruleset  \n],\nlogger_level=logging.ERROR\n)\n# Chat function\ndef chat(agent):\nis_chatting = True\nwhile is_chatting:\nuser_input = Prompt.ask(\"[grey50]Chat\")\nis_chatting = agent.respond(user_input)\n# Introduce the agent\nagent.respond(\"Introduce yourself.\")\n# Run the agent#\nchat(agent)\n</code></pre>"},{"location":"200/chatbot-rulesets/14_making_it_quick/#all-done","title":"All Done!","text":"<p>Success</p> <p>You did it!</p> <p>That's it! We've come a long way in this tutorial series and now you have a multi-persona chat application written with Griptape. Hopefully you've been able to see how using Rulesets can be used for both creative and structural control of your applications.</p> <p>Congratulations on making it through! We're thrilled you decided to join us for this course and we hope you've enjoyed it as much as we have. We'd love to hear your feedback, so please don't hesitate to let us know what you thought.</p> <p>More importantly, we wish you all the best as you continue your journey with Griptape and Python. Remember to have fun, experiment, and keep on learning. Happy coding! \ud83d\ude80</p>"},{"location":"200/compare-movies-workflow/","title":"Learn Griptape Workflows through Cinematic Comparison","text":"<pre><code>graph TB\n    A[Workflow] \n    B(\"Task 1a\")\n    C(\"Task 1b\"):::tool\n    I(\"Summary\")\n    G(\"Task 2a\")\n    H(\"Task 2b\"):::tool\n    F(\"Task 3\")\n    J([\"\\n  Output \\n\\n\"]):::output\n\n    A --&gt; B --&gt; C --&gt; I\n    A --&gt; G --&gt; H --&gt; I\n    A --&gt; F\n    I --&gt; J\n    F ---&gt; I\n\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n    classDef output fill:#5552,stroke:#555\n</code></pre>"},{"location":"200/compare-movies-workflow/#course-description","title":"Course Description","text":"<p>Griptape Workflows allow you to create complicated parent-child task relationships, where one task won't begin until all it's parent tasks have completed. Using movie narratives as our backdrop, you'll gain practical experience in establishing inter-task connections and seeing how they collaboratively weave a coherent story. Ideal for those keen on understanding the intricacies of Griptape's Workflows while engaging in a compelling thematic exploration.</p>"},{"location":"200/compare-movies-workflow/#what-you-will-create","title":"What you will create","text":"<p>Below you can see a representation of the workflow graph we will create in the course, where you will pass rough descriptions of movies, then for each movie a series of tasks will be executed:</p> <ol> <li>Get the actual name of the movie.</li> <li>Search the web and get a very short description of the movie.</li> </ol> <p>Finally, once all tasks are finished, a final comparison task will be executed of the three movies and output the results.</p> <pre><code>graph TB\n    A[\"&lt;h4&gt;Workflow&lt;/h4&gt;\n    Given some rough movie descriptions,\n    describe their similarities.\n    &lt;br&gt;\"] --&gt; AB([\"A boy finds an alien\"]):::Result\n    AB --&gt; B(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Get Name\"):::PromptTask\n\n    A --&gt; AC([\"Black and white movie turns color\"]):::Result\n    AC --&gt; C(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Get Name\"):::PromptTask\n\n    A --&gt; AD([\"Kid suddenly becomes big\"]):::Result\n    AD --&gt; D(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Get Name\"):::PromptTask\n\n    K(\"&lt;b&gt;PromptTask&lt;/b&gt;:&lt;br&gt;Compare Movies\"):::PromptTask\n    subgraph movie 1 [\" \"]\n    B --&gt; BE([E.T.]):::Result\n    BE --&gt; E(\"&lt;b&gt;ToolkitTask&lt;/b&gt;:&lt;br&gt;Get Summary\"):::ToolkitTask\n    E --&gt; HK([\"A troubled child summons \\nthe courage to help \\na friendly alien ...\"]):::Result\n    end\n\n    subgraph movie 2 [\" \"]\n    C --&gt; CF([Wizard of Oz]):::Result\n    CF --&gt; F(\"&lt;b&gt;ToolkitTask&lt;/b&gt;:&lt;br&gt;Get Summary\"):::ToolkitTask\n    F --&gt; IK([\"A classic film from \\n1939 in which young \\nDorothy Gale and her\\ndog Toto ...\"]):::Result\n\n    end\n    subgraph movie 3 [\" \"]\n    D --&gt; CG([Big]):::Result\n    CG --&gt; G(\"&lt;b&gt;ToolkitTask&lt;/b&gt;:&lt;br&gt;Get Summary\"):::ToolkitTask\n    G --&gt; JK([\"After wishing to be\\nmade big, a teenage boy\\nwakes to find ...\"]):::Result\n    end\n    HK ---&gt; K\n    IK ---&gt; K\n    JK ---&gt; K\n\n    K --&gt; L([\"\\nAll three movies:\n    &lt;i&gt;E.T. the Extra-Terrestrial&lt;/i&gt;, &lt;i&gt;The Wizard of Oz&lt;/i&gt;, and &lt;i&gt;Big&lt;/i&gt;, \n            share a common theme of fantastical journeys and adventures.    \n            They all involve characters who are thrust into extraordinary \n            circumstances that are far removed from their normal lives.\\n\\n\"]):::Result\n\n    classDef PromptTask stroke:#A00\n    classDef ToolkitTask stroke:#f06090\n    classDef Result fill:#5552,stroke:#555\n</code></pre>"},{"location":"200/compare-movies-workflow/#who-is-this-course-for","title":"Who is this course for?","text":"<p>This course is aimed at intermediate level Python developers who are interested in learning about Griptape Workflows and how to handle parent/child task relationships. </p>"},{"location":"200/compare-movies-workflow/#prerequisites","title":"Prerequisites","text":"<p>Before beginning this course, you will need:</p> <ul> <li>An OpenAI API Key (available here: https://beta.openai.com/account/api-keys)</li> <li>Python3.9+ installed on your machine</li> <li>An IDE (such as Visual Studio Code or PyCharm) to write and manage your code</li> </ul> <p>If you don't have those items available, it's highly recommended you go through the Griptape Setup - Visual Studio Code course to set up your environment.</p>"},{"location":"200/compare-movies-workflow/#course-outline","title":"Course Outline","text":"<p>The course will cover:</p> <ul> <li>Creating your first workflow</li> <li>Making it scalable</li> <li>Handling inputs with Jinja2 templates</li> <li>Using the WebScraper tool</li> <li>Understanding Workflow Outputs</li> </ul>"},{"location":"200/compare-movies-workflow/#useful-resources","title":"Useful Resources","text":"<p>These resources will provide additional information and context throughout the course:</p> <ul> <li>Griptape Documentation</li> <li>Visual Studio Code</li> <li>Jinja2 Documentation</li> </ul>"},{"location":"200/compare-movies-workflow/#next-steps","title":"Next Steps","text":"<p>Get yourself all setup and ready by moving on to Setup.</p>"},{"location":"200/compare-movies-workflow/01_setup/","title":"Setup","text":"<p>As with any project, the first step is setting up your environment. Let's get started by ensuring you have a project structure ready to work with.</p>"},{"location":"200/compare-movies-workflow/01_setup/#prerequisites","title":"Prerequisites","text":"<p>Important</p> <p>Since this is an intermediate level course, please ensure you've gone through the Griptape Setup - Visual Studio Code course to set up your environment. We will be starting from the code at that point.</p> <ol> <li> <p>Code Editor: We recommend using Visual Studio Code for this course, due to its handy features and Python support. However, if you have another favorite IDE or text editor, feel free to use that! </p> </li> <li> <p>Python3.9+: Griptape requires Python 3.9 and above.</p> </li> <li> <p>Python Environment Manager (for VS Code users): This extension is not a hard requirement, but it does make managing your Python environments a lot easier. </p> </li> <li> <p>OpenAI API Key: Our chatbot will be powered by gpt-4, which requires an API key from OpenAI. You can get your key from OpenAI's website.</p> </li> </ol> <p>Got everything installed? Awesome! Now, let's get started setting up our project.</p>"},{"location":"200/compare-movies-workflow/01_setup/#create-a-project","title":"Create a Project","text":"<p>Following the instructions in Griptape Setup - Visual Studio Code  please:</p> <ol> <li>Create your project folder. Example: <code>griptape-compare-movies-workflow</code></li> <li>Set up your virtual environment</li> <li>Ensure you <code>pip install griptape griptape-tools python-dotenv</code></li> <li>Create a <code>.env</code> file with your <code>OPENAI_API_KEY</code></li> <li>Create your <code>app.py</code> file with the following code:</li> </ol> app.py<pre><code>from dotenv import load_dotenv\nload_dotenv() # Load your environment\n</code></pre>"},{"location":"200/compare-movies-workflow/01_setup/#next-steps","title":"Next Steps","text":"<p>And there we have it, environment is all set up! In the next section Concepts, we'll dive deeper into understanding the concepts of Pipelines, Workflows, and Tasks.</p>"},{"location":"200/compare-movies-workflow/02_concepts/","title":"Main Concepts","text":""},{"location":"200/compare-movies-workflow/02_concepts/#understanding-workflows-and-pipelines","title":"Understanding Workflows and Pipelines","text":"<p>Frequently when creating applications you will want to execute a series of steps in a very specific order. Workflows and Pipelines are both structures that allow us to do that. They have many of the same features as Agents, but are more directable. Whereas Agents can be given behaviors and tools and will use them when prompted appropriately, Pipelines and Workflows utilize hieararchies of tasks in very specific ways.</p>"},{"location":"200/compare-movies-workflow/02_concepts/#pipelines","title":"Pipelines","text":"<p>Pipelines are always a sequential series of steps - one task after another until it is finished. They have a single output, and just like Agents, they can use Memory.</p> <p>In this course we're going to be taking some rough descriptions of movies and getting their actual names, then getting the summaries from the web and comparing them. Doing this as a Pipeline might look something like:</p> <ol> <li>Get movie descriptions</li> <li>Get the actual name of the movie</li> <li>Look up the summary </li> </ol> <p>The flow of tasks would be:</p> <pre><code>graph LR\n    A(Movie Description) --&gt; C(Get Name ) --&gt; D(Get Summary)</code></pre> <p>This works great for our simple task, but the point of this course is to compare multiple movies. If we use a standard linear pipeline, it would mean:</p> <pre><code>graph LR\n    A(Movie Descriptions) --&gt; B(Get Name 1) --&gt; D(Get Summary 1) --&gt; E(Get Name 2) \n    E --&gt; F(Get Summary 2) --&gt; G(\"Get Name &lt;i&gt;n&lt;/i&gt;\" ):::dash --&gt; H(\"Get Summary &lt;i&gt;n&lt;/i&gt;\"):::dash \n    H --&gt; I(Compare)\n\n    classDef dash stroke-dasharray: 5 5\n</code></pre> <p>As you can tell, this could get quite unweildy. In addition, it doesn't make much sense for getting the name of the 4th movie to have to wait until the summary of the 3rd movie is figured out, as they're not really dependent on each other.</p> <p>Workflows are perfect for this sort of situation. They allow you to parallelize tasks that aren't dependent. Let's see how something like this might look.</p>"},{"location":"200/compare-movies-workflow/02_concepts/#workflows","title":"Workflows","text":"<p>Workflows allow for complex interactions, resembling tree branches.</p> <p>Workflows are non-sequential and can contain multiple outputs. Because their flows can be quite complicated, they don't contain ConversationalMemory.</p> <p>This is what a Workflow might look like for doing what we mentiond above. </p> <p>Note</p> <p>The graph is drawn top to bottom for this example because it's easier to understand the flow of data, but it can be drawn in either direction.</p> <pre><code>graph TB\n    A(Movie Descriptions) --&gt; B(Get Name 1) --&gt; D(Get Summary 1) --&gt; I(Compare)\n    A --&gt; E(Get Name 2) --&gt; F(Get Summary 2) --&gt; I\n    A --&gt; G(\"Get Name &lt;i&gt;n&lt;/i&gt;\" ):::dash\n    G --&gt; H(\"Get Summary &lt;i&gt;n&lt;/i&gt;\"):::dash \n    H --&gt; I\n    classDef dash stroke-dasharray: 5 5\n</code></pre> <p>Notice how the movies can be evaluated in parallel, but the Compare task will wait until all it's parent tasks are completed. </p>"},{"location":"200/compare-movies-workflow/02_concepts/#tasks","title":"Tasks","text":"<p>Before we dive in and start setting up our own workflow, it's important to review the concepts of Tasks. With Griptape, there are two types of tasks you'll be working with:</p> <ul> <li>PromptTask</li> <li>ToolkitTask</li> </ul> <p>Both of these task types are used to work with the LLM. They both take an input as a prompt, can take arguments, use specific drivers, and have parent/child relationships. The main difference between them is that ToolkitTasks can also use tools like Calculator(), FileBrowser(), and more. View all the tools available with Griptape here.</p> <pre><code># Example PromptTask to get a movie name\n#\nmovie_task = PromptTask(\n\"What is this movie: {{ descr }}\",\ncontext = {                        \n\"descr\": \"princess and farmhand named Wesley\" \n},\nid=\"movie_id\"                      # task id can be referenced by other tasks\n)\n# This ToolkitTask works with the output of the previous task, and can use tools.\n#\ndescribe_task = ToolkitTask(\n\"Get the description of this movie: {{ inputs['movie_id'] }}\",       \ntools = [                          \nWebScraper()\n],\nid='describe_id')\n</code></pre> <p>I have found that the best way to really understand how PromptTasks and ToolkitTasks work is to use them in context. So let's move on to the next section where we'll create our First Workflow, and get an understanding of the basics of how parent/child relationships can work.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/","title":"First Workflow","text":""},{"location":"200/compare-movies-workflow/03_first_workflow/#overview","title":"Overview","text":"<p>In this section we're going to create the first workflow in our Movie Comparison application. By the end of this section you will have a workflow that lets you create a cursury comparision between two movies.</p> <p>For example, if you pass it these two descriptions:</p> <ul> <li>\"A boy discovers an alien in his back yard\"</li> <li>\"A shark attacks a beach\"</li> </ul> <p>It will come back with:</p> <p>Result</p> <p>Both E.T. the Extra-Terrestrial and Jaws are directed by Steven Spielberg.   They are also both iconic films that have had a significant impact on popular culture.</p> <p>The hierarchy we will create looks like the following:</p> <pre><code>graph TB\n    A[Workflow] --&gt; B(Movie 1) --&gt; D(Compare Task)\n    A --&gt; C(Movie 2) --&gt; D\n</code></pre> <p>As you can see, there are three tasks that will be created. Two will be siblings (Movie 1 and Movie 2), and one will be dependent on them to complete before it can execute (Compare Task).</p> <p>Let's get started.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#importing-required-modules","title":"Importing Required Modules","text":"<p>Before starting, we need to import the necessary modules. Open the <code>app.py</code> file you created in the setup section and import the two Griptape classes you'll need: <code>Workflow</code> and <code>PromptTask</code>:</p> <pre><code>from dotenv import load_dotenv\n# Griptape\nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask\nload_dotenv() # Load your environment\n</code></pre> <p>Note</p> <p>You might recall that <code>Agent</code> was also imported through <code>griptape.structures</code>. That's because <code>Agent</code>, <code>Workflow</code>, and <code>Pipeline</code> are all Griptape's ways of working with LLMs. </p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#first-workflow-tasks","title":"First Workflow Tasks","text":""},{"location":"200/compare-movies-workflow/03_first_workflow/#initialize-the-workflow","title":"Initialize the Workflow","text":"<p>Now, let's create the foundation for our Workflow. After the line <code>load_dotenv()</code>, create an instance of the Workflow class:</p> <pre><code># ... truncated for brevity\nload_dotenv() # Load your environment\n# Create the workflow object\nworkflow = Workflow()\n</code></pre>"},{"location":"200/compare-movies-workflow/03_first_workflow/#create-a-task","title":"Create a Task","text":"<p>Next, let's create our first <code>PromptTask</code>. This task will be used to simply ask to the LLM to tell us what movie we're talking about.</p> <p>After the <code>workflow</code> line, add:</p> <pre><code># Create tasks\nmovie_1_task = PromptTask(\"What movie is this: boy finds alien in backyard.\", id=\"movie_1\")\n</code></pre> <p>There are two things that are important to point out in this task creation.</p> <ol> <li>Notice that we're using a <code>PromptTask</code>. That's because we don't need to use any tools for this particular task, we only want to use the LLM.</li> <li>We have given the task an <code>id</code>. This is so we can reference it later in the script. If you don't pass this value, the task will be given a random string as the id.</li> </ol> <p>Important</p> <p>Every task in a workflow must have a unique id. If two tasks have the same id, the workflow will fail.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#add-task-to-the-workflow","title":"Add Task to the Workflow","text":"<p>You have created the task, but it's not yet part of the workflow. In order to do that, we'll need to use the <code>add_task</code> method.</p> <p>After the PromptTask line, add:</p> <pre><code># Add tasks to workflow\nworkflow.add_task(movie_1_task)\n</code></pre> <p>At this point, your workflow flow graph looks like:</p> <pre><code>graph TB\n    A[workflow] --&gt; B(PromptTask: movie_1_task)</code></pre> <p>However if you execute your script, nothing will happen. That's because you need to tell the workflow graph to run.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#run-the-workflow","title":"Run the Workflow","text":"<p>To run a workflow, you simply need to call the method <code>run</code>:</p> <pre><code># Run the workflow\nworkflow.run()\n</code></pre> <p>Here's the result. Notice in the logs you can see the Task inputs and outputs: <pre><code>[08/12/23 19:53:08] INFO     Task movie_1                                                                          Input: What movie is this?: A boy discovers an alien in his back yard                 [08/12/23 19:53:10] INFO     Task movie_1                                                                          Output: That sounds like the movie \"E.T. the Extra-Terrestrial\".                      </code></pre></p> <p>As you can see, the LLM was able to determine what movie it was.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#another-task","title":"Another Task","text":"<p>This is still a very linear pipeline. In fact, there's only one task in the workflow. Let's go ahead and add our second task.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#second-movie-task","title":"Second Movie Task","text":"<p>Just below the first movie PromptTask, add a second one with another description.</p> <pre><code># ...\n# Create tasks\nmovie_1_task = PromptTask(\"What movie is this: boy finds alien in backyard.\", id=\"movie_1\")\nmovie_2_task = PromptTask(\"What movie is this?: a shark attacks a beach.\", id=\"movie_2\")\n# ...\n</code></pre> <p>Important</p> <p>Don't forget to add the id to the second task and make sure it's unique from the first task.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#add-second-task-to-workflow","title":"Add Second Task to Workflow","text":"<p>Just like before, we need to add <code>movie_2_task</code> to <code>workflow</code> with the <code>add_task</code> method.</p> <p><pre><code># ...\n# Add tasks to workflow\nworkflow.add_task(movie_1_task)\nworkflow.add_task(movie_2_task)\n# ...\n</code></pre> This adds the task as a sibling of the first task, because we added it to the <code>workflow</code> object.</p> <p>You can see this in the resulting graph: <pre><code>graph TB\n    A[workflow] --&gt; B(PromptTask: movie_1_task)\n    A --&gt; C(PromptTask: movie_2_task)</code></pre></p> <p>And if we run the script, you'll see both tasks being executed in parallel, and both outputs.</p> <pre><code>[08/12/23 20:03:14] INFO     Task movie_1                                                                          Input: What movie is this?: A boy discovers an alien in his back yard                 INFO     Task movie_2                                                                          Input: What movie is this?: a shark attacks a beach.                                  [08/12/23 20:03:16] INFO     Task movie_1                                                                          Output: That sounds like the movie \"E.T. the Extra-Terrestrial\".                      INFO     Task movie_2                                                                          Output: That could be several movies, but the most famous one is probably \"Jaws\".  </code></pre>"},{"location":"200/compare-movies-workflow/03_first_workflow/#comparison","title":"Comparison","text":"<p>You'll remember that our goal in this section is to get a simple comparison of the two movies. In order to do this we'll need to create another task where we ask the LLM to compare the results of the previous tasks.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#comparison-task","title":"Comparison Task","text":"<p>After the previous movie PromptTasks, create a compare task.</p> <pre><code># ...\nmovie_1_task = PromptTask(\"What movie is this?: A boy discovers an alien in his back yard\", id=\"movie_1\")\nmovie_2_task = PromptTask(\"What movie is this?: a shark attacks a beach.\", id=\"movie_2\")\ncompare_task = PromptTask(\"How are these movies the same?\", id=\"compare\")\n# ...\n</code></pre>"},{"location":"200/compare-movies-workflow/03_first_workflow/#make-the-compare-task-a-child","title":"Make the Compare Task a Child","text":"<p>Now we get to create our first child task. We want the Compare task to only evaluate after the two movie tasks have completed.</p> <p>This can be done by using the <code>add_child</code> method with the task you want to be the <code>parent</code>.</p> <p>After the <code>workflow.add_task</code> lines, add the following:</p> <p><pre><code>movie_1_task.add_child(compare_task)\n</code></pre> This adds the <code>compare</code> task as a child to only the <code>movie_1</code> task. This is what the graph looks like:</p> <pre><code>graph TB\n    A[workflow] --&gt; B(PromptTask: movie_1_task)\n    A --&gt; C(PromptTask: movie_2_task)\n    B --&gt; D(PromptTask: compare_task)</code></pre> <p>This obviously isn't what we want, we want both movie tasks to be the parent of the compare task. Luckily, that's easily accomplished by by just adding another <code>add_child</code> line. Here's what that section of code should look like:</p> <pre><code># ...\n# Add tasks to the workflow\nworkflow.add_task(movie_1_task)\nworkflow.add_task(movie_2_task)\n# Add compare as a child\nmovie_1_task.add_child(compare_task)\nmovie_2_task.add_child(compare_task)\n# ...\n</code></pre> <p>And the resulting graph:</p> <pre><code>graph TB\n    A[workflow] --&gt; B(PromptTask: movie_1_task)\n    A --&gt; C(PromptTask: movie_2_task)\n    B --&gt; D(PromptTask: compare_task)\n    C --&gt; D</code></pre>"},{"location":"200/compare-movies-workflow/03_first_workflow/#test","title":"Test","text":"<p>Go ahead and run the code and notice the result:</p> <pre><code># ... truncated for brevity\n[08/12/23 20:54:56] INFO     Task compare                                                 Output: To provide an accurate response, could you please specify which movies you are\n                             referring to?            </code></pre> <p>Hmm. It doesn't look like the <code>compare</code> task knows what we're talking about. The workflow evaluated both we sent it, we can see that in the logs above, but the compare task has no knowledge of them. </p> <p>That's because we need to pass the results of the previous task to the current task. This is a very important feature, as it allows us to be very specific about what data is sent to the LLM.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#pass-the-data","title":"Pass the Data","text":"<p>In order to send the data to the PromptTask, we need to somehow feed the result of the previous task's execution to the prompt.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#jinja2","title":"Jinja2","text":"<p>Griptape uses the Jinja2 template engine, which allows you to insert data into the prompt. There's a lot of power available with Jinja templates, but in this course we'll keep our focus rather small.</p> <p>Jinja templates access variables using the <code>{{ }}</code> syntax. Tasks have a property <code>inputs</code> that tell us what objects are coming into the node.</p> <p>Note</p> <p>The <code>inputs</code> property may be changing shortly to <code>parent_output</code>. This document will be updated when that happens.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#update-the-prompt","title":"Update the Prompt","text":"<p>In order to update the prompt, we want to tell it what tasks to be looking at. If you check your code, you can see that we used the <code>id</code> property earlier when we were creating the tasks:</p> <pre><code>movie_1_task = PromptTask(\"What movie is this?: A boy discovers an alien in his back yard\", id=\"movie_1\")\nmovie_2_task = PromptTask(\"What movie is this?: a shark attacks a beach.\", id=\"movie_2\")\n</code></pre> <p>So <code>movie_1</code> and <code>movie_2</code> are the two ids we can use in our Jinja template. They can be specified like this: <code>{{ inputs['movie_1'] }}</code> and <code>{{ inputs['movie_2'] }}</code></p> <p>Update the <code>compare</code> task to specify the particular ids of the inputs. Note - I'm using <code>\"\"\"</code> in order to allow us to use multiple lines for the PromptTask string.</p> <pre><code>compare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {{ inputs['movie_1'] }}\n    {{ inputs['movie_2'] }}\n    \"\"\",\nid=\"compare\")\n</code></pre>"},{"location":"200/compare-movies-workflow/03_first_workflow/#test_1","title":"Test","text":"<p>When you run the script now, you should see a much better Input:</p> <pre><code>[08/12/23 21:34:59] INFO     Task compare                                                                          Input:                                                                                How are these movies the same:                                                    That sounds like the movie \"E.T. the Extra-Terrestrial\".                          That could be several movies, but the most famous one is probably \"Jaws\".         [08/12/23 21:35:02] INFO     Task compare                                                                          Output: Both \"E.T. the Extra-Terrestrial\" and \"Jaws\" are iconic films directed by     Steven Spielberg. They are known for their memorable storylines, groundbreaking       special effects for their time, and their significant impact on popular culture.  </code></pre> <p>The code works but it's if you look closely at the <code>compare</code> task input, you'll see that it's using the full string of the response from the prompts:</p> <pre><code>How are these movies the same:                                                    That sounds like the movie \"E.T. the Extra-Terrestrial\".                          That could be several movies, but the most famous one is probably \"Jaws\". </code></pre> <p>What we really want is just the name of the movie, not any commentary. We can fix that by adjusting the prompt in the initial query.</p>"},{"location":"200/compare-movies-workflow/03_first_workflow/#fix-the-prompt","title":"Fix the Prompt","text":"<p>Change the movie PromptTasks so we ask for just the name: <pre><code>movie_1_task = PromptTask(\n\"What movie is this? Return only the movie name: A boy discovers an alien in his back yard\", \nid=\"movie_1\")\nmovie_2_task = PromptTask(\n\"What movie is this? Return only the movie name: a shark attacks a beach.\", \nid=\"movie_2\")\n</code></pre></p> <p>After running the response input task should be much cleaner:</p> <pre><code>How are these movies the same: E.T. the Extra-Terrestrial                  Jaws   </code></pre>"},{"location":"200/compare-movies-workflow/03_first_workflow/#code-review","title":"Code Review","text":"<p>We covered quite a lot of ground creating your first workflow. Double-check your script and make sure you've got it working as expected:</p> app.py<pre><code>from dotenv import load_dotenv\n# Griptape \nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask\n# Load environment variables\nload_dotenv()\n# Create a Workflow\nworkflow = Workflow()\n# Create tasks\nmovie_1_task = PromptTask(\n\"What movie is this? Return only the movie name: A boy discovers an alien in his back yard\", \nid=\"movie_1\")\nmovie_2_task = PromptTask(\n\"What movie is this? Return only the movie name: a shark attacks a beach.\", \nid=\"movie_2\")\ncompare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {{inputs['movie_1']}}\n    {{inputs['movie_2']}}\n    \"\"\",\nid=\"compare\")\n# Add tasks to the workflow\nworkflow.add_task(movie_1_task)\nworkflow.add_task(movie_2_task)\n# Add compare as a child\nmovie_1_task.add_child(compare_task)\nmovie_2_task.add_child(compare_task)\n# Run the workflow\nworkflow.run()\n</code></pre>"},{"location":"200/compare-movies-workflow/03_first_workflow/#next-step","title":"Next Step","text":"<p>In the next section we are going to make our script a bit more flexible by making it possible to compare as many movie descriptions as we want. Check out Adding Flexibility when you're ready to continue.</p>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/","title":"Adding Flexibility","text":""},{"location":"200/compare-movies-workflow/04_adding_flexibility/#overview","title":"Overview","text":"<p>In the previous section you created your first workflow. It works well for two movie descriptions, however if you want to expand to more movies it could be a bit difficult for a few reasons.</p> <ol> <li>We're creating the tasks and adding them to the workflow one at a time.</li> <li>In the comparison task we target the specific ids of the movie tasks.</li> <li>We're repeating our prompt \"What movie is this? Return only the name\" over and over again.</li> </ol> <p>So in this section, we'll make our application more flexible by defining a list of movie descriptions, and then iterate through that list to create PromptTasks and add them to the workflow.</p>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#movie-description-list","title":"Movie Description List","text":"<p>Locate the section of your code where you create the list of movie tasks: <pre><code># ...\n# Create tasks\nmovie_1_task = PromptTask(\n\"What movie is this? Return only the movie name: A boy discovers an alien in his back yard\", \nid=\"movie_1\")\nmovie_2_task = PromptTask(\n\"What movie is this? Return only the movie name: a shark attacks a beach.\", \nid=\"movie_2\")\n# ...\n</code></pre></p> <p>We're going to replace this entire section with a <code>descriptions</code> list instead. This will be a list of python dictionaries with an \"id\" and a \"descriptoin\".</p> <p>It should look something like: <pre><code># Create a list of movie descriptions\nmovie_descriptions = [\n\"A boy discovers an alien in his back yard\",\n\"A shark attacks a beach\"\n]\n</code></pre></p>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#iterate-through-list","title":"Iterate through list","text":"<p>Now to create our PromptTasks, we'll iterate through the list of movie_descriptions.</p> <p>Locate the code after the <code>compare_task</code> where we add tasks to the workflow:</p> <pre><code># Add tasks to the workflow\nworkflow.add_task(movie_1_task)\nworkflow.add_task(movie_2_task)\n# Add compare as a child\nmovie_1_task.add_child(compare_task)\nmovie_2_task.add_child(compare_task)\n</code></pre> <p>We will replace this with a for loop where we create the PromptTask and add it to the workflow.</p> <pre><code># ...\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\nmovie_task = PromptTask(\n\"What movie title is this? Return only the movie name: {{ description }}\",\ncontext = {\n\"description\": description\n})\nworkflow.add_task(movie_task)\n# Add compare as a child\nmovie_task.add_child(compare_task)\n# ...\n</code></pre> <p>As you can see, we:</p> <ol> <li>Iterate through each <code>description</code> in the list of <code>movie_descriptions</code>. </li> <li>Create a <code>PromptTask</code> and pass that <code>description</code> to the <code>context</code> into a variable also called <code>description</code>.</li> <li>Use that variable via Jinja2 templates in the prompt itself: <code>{{ description }}</code>.</li> <li>Once the <code>PromptTask</code> is created, we add it to the workflow using the <code>add_task</code> method.</li> <li>Add <code>compare_task</code> as a child to the task using the <code>add_child</code> method.</li> </ol>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#update-compare-task","title":"Update Compare Task","text":"<p>There's one final step we need to take before we can run this. In our <code>compare_task</code>, we're specifically identifying <code>movie_1</code> and <code>movie_2</code> in the prompt:</p> <pre><code>compare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {{inputs['movie_1']}}\n    {{inputs['movie_2']}}\n    \"\"\",\nid=\"compare\")\n</code></pre> <p>This will no longer work because we are not defining the ids when we create the PromptTask - we just let it come up with it's own unique identifiers. Also, we don't know exactly how many movies we might be comparing, so it doesn't make much sense to define and add each one individually.</p> <p>Luckily, intead of specifically specifying the items via id, we can just say \"hey - give me all the input items\" using <code>{{ inputs.items() }}</code>. This will return the entire <code>dict</code> of items that are input to the task.</p> <p>Replace the two lines:</p> <pre><code>    {{inputs['movie_1']}}\n{{inputs['movie_2']}}   \n</code></pre> <p>with:</p> <pre><code>    {{ inputs.items() }}\n</code></pre> <p>The <code>compare_task</code> section should now look like:</p> <pre><code>compare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {{ inputs.items() }}\n    \"\"\",\nid=\"compare\")\n</code></pre>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#test","title":"Test","text":"<p>Let's run the code and see what we get.</p> <pre><code>[08/13/23 10:08:28] INFO     Task compare                                                                                                                     Input:                                                                                                                           How are these movies the same:                                                                                               dict_items([('60b7763430c24ca1bb0bffacb016f37f', 'E.T. the Extra-Terrestrial'), ('f6810857060e4b029ff66ff8a2f35be9',         'Jaws')])                                                                                                                        [08/13/23 10:08:31] INFO     Task compare                                                                                                                     Output: Both 'E.T. the Extra-Terrestrial' and 'Jaws' are iconic movies directed by Steven Spielberg. They are known for their    memorable storylines and have had a significant impact on popular culture.                                                       </code></pre> <p>We get the proper output for our task - it compares ET and Jaws as we expect. But notice the input.</p> <pre><code>Input:                                                                                                                           How are these movies the same:                                                                                               dict_items([('60b7763430c24ca1bb0bffacb016f37f', 'E.T. the Extra-Terrestrial'), ('f6810857060e4b029ff66ff8a2f35be9',         'Jaws')])                               </code></pre> <p>Instead of passing just the names of the movies, it's passing the entire dictionary of items. It works but it's messy. Don't worry, there's a way to clean this up using Jinja2 for loops.</p>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#iterate-through-items","title":"Iterate Through Items","text":"<p>Jinja2 has a for loop structure that looks like: <pre><code>{% for item in list %}\n{{ item }}\n{% endfor %}\n</code></pre></p> <p>We can use this inside our PromptTask to iterate through the items and just output the names.</p> <p>Replace the <code>{{ inputs.items }}</code> section of the <code>PromptTask</code> with a for loop that will get the key/value pairs (id, movie name) and output just the value.</p> <pre><code># ... \ncompare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {% for key, value in inputs.items() %}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\nid=\"compare\")\n# ...\n</code></pre>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#test_1","title":"Test","text":"<p>Run the script again and let's see how it looks.</p> <pre><code>INFO     Task compare\n            Input:\n                How are these movies the same:\n                E.T. the Extra-Terrestrial\n                Jaws\n</code></pre> <p>Much better. Go ahead and add a third movie to the structure and run it again. Everything should work as expected. I added \"A princess and a man named Wesley\" (from the movie The Princess Bride) and got the following result:</p> <p>Result</p> <p>All three movies, E.T. the Extra-Terrestrial, Jaws, and The Princess Bride, are iconic films   from the late 20th century. They all fall under the genre of adventure and have elements of fantasy.   Additionally, they have been highly influential in popular culture and have received critical acclaim.  </p>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#code-review","title":"Code Review","text":"<p>There was not as much work in this section, but we did conver some important concepts. </p> <ul> <li>We made our code more flexible by using a list of descirptions to create PromptTasks instead of creating them one at a time.</li> <li>We used a Jinja2 template for loop to iterate through each incoming item.</li> </ul> <p>Review your code with the current state to make sure everything is working as expected.</p> app.py<pre><code>from dotenv import load_dotenv\n# Griptape \nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask\n# Load environment variables\nload_dotenv()\n# Create a Workflow\nworkflow = Workflow()\n# Create a list of movie descriptions\nmovie_descriptions = [\n\"A boy discovers an alien in his back yard\",\n\"A shark attacks a beach\",\n\"A princess and a man named Wesley\"\n]\ncompare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {% for key, value in inputs.items()%}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\nid=\"compare\")\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\nmovie_task = PromptTask(\n\"What movie title is this? Return only the movie name: {{ description }} \",\ncontext={\"description\": description})\nworkflow.add_task(movie_task)\nmovie_task.add_child(compare_task)\n# Run the workflow\nworkflow.run()\n</code></pre>"},{"location":"200/compare-movies-workflow/04_adding_flexibility/#next-step","title":"Next Step","text":"<p>Our code works, but the descriptions of the movies aren't as detailed as they could be. It would be better if we could search the web for detailed information about the movies, and use those results for a more comprehensive comparison.</p> <p>In the next section we will add to our workflow by adding a ToolkitTask that uses the <code>WebScraper</code> tool to get more detailed information. Jump to Using Tools when you're ready to continue.</p>"},{"location":"200/compare-movies-workflow/05_using_tools/","title":"Using Tools","text":""},{"location":"200/compare-movies-workflow/05_using_tools/#overview","title":"Overview","text":"<p>We added flexibility in the last section to allow our application to handle an undefined number of movies. The workflow hierarchy looks like:</p> <pre><code>graph TB\n    A(Movie Descriptions) --&gt; B(\"PromptTask: Movie Task 1\") --&gt; I(\"PromptTask: Compare\")\n    A --&gt; G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n    G --&gt; I\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n</code></pre> <p>However, the comparisons coming back don't feel very deep and meaningful. We'd like to get a more detailed analysis of the film comparisons by getting a better summary of each film from the web. </p> <p>To do that we'll use add a <code>ToolkitTask</code> to our workflow for each movie. This will result in the following chart. .</p> <p>So in this section, we'll make our application more flexible by defining a list of movie descriptions, and then iterate through that list to create PromptTasks and insert them into the workflow.</p> <pre><code>graph TB\n    A(Movie Descriptions) --&gt; B(\"PromptTask: Movie Task 1\") --&gt; C(\"ToolkitTask: Summary Task 1\"):::tool --&gt; I(\"PromptTask: Compare\")\n    A --&gt; G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash  --&gt; H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\"):::tool-dash\n    H --&gt; I\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n</code></pre>"},{"location":"200/compare-movies-workflow/05_using_tools/#import","title":"Import","text":"<p>The two new classes we'll need to import are <code>ToolkitTask</code> and <code>WebScraper</code>.</p> <p>ToolkitTask is a task just like PromptTask, except it allows you to specify the use of Tools. </p> <p>WebScraper is a specific tool that allows the LLM to scrape the web for information. We'll use this to get a better summary of each movie.</p> <p>In the top of your application, modify the import statements to include ToolkitTask and WebScraper</p> <pre><code>from dotenv import load_dotenv\n# Griptape \nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask, ToolkitTask\nfrom griptape.tools import WebScraper\n</code></pre>"},{"location":"200/compare-movies-workflow/05_using_tools/#summary-toolkittask","title":"Summary ToolkitTask","text":"<p>Now we'll add the <code>ToolkitTask</code> to the section of our code where we iterate through each movie description.</p> <p>We will call it the same way we do PromptTask, except the ToolkitTask takes a list of tools.</p> <pre><code>summary_task = ToolkitTask(\n\"Give me a summary of the movie: {{ }}\", \ntools = [WebScraper()]\n)\n</code></pre> <p>When we call the <code>ToolkitTask</code> we'll need to pass the output of the previous task (the movie_task) to it. There are a few options we can use to do this, depending on the needs of our application.</p>"},{"location":"200/compare-movies-workflow/05_using_tools/#option-1-all-incoming-items","title":"Option 1: All Incoming Items","text":"<p>If you recall from the previous section, using the Jinja Template <code>{{ inputs.items() }}</code> will give you a list of dicts from all incoming tasks. </p> <p>Example:  <pre><code>    \"Give me a summary of the movie: {{ input.items() }}\"\n</code></pre></p> <p>In this case, the return would look something like: <pre><code>Input: Give me a summary of the movie:dict_items([('aff5c7989898483c93a14f40467ec2be',   \n'E.T. the Extra-Terrestrial')])                                                                         \n</code></pre></p> <p>While this works, it does provide a lot of extraneous information. We know that there is only one item coming in - so it's not necessary to use this list of dicts. Jinja2 provides filters to reduce this.</p>"},{"location":"200/compare-movies-workflow/05_using_tools/#option-2-filter-for-one-item","title":"Option 2: Filter for One Item","text":"<p>Jinja2 allows you to use filters to return specific information. The format with Jinja2 is to use a <code>|</code> notation to add a filter.</p> <p>For example, instead of using <code>{{ input.items() }}</code>, we can filter it to return a <code>list</code>, and then also get just the <code>last</code> item in the list. That would look like: <code>{{ inputs.items()|list|last }}</code>:</p> <pre><code>    \"Give me a summary of the movie: {{ input.items()|list|last }}\"\n</code></pre> <p>And the result would be:</p> <pre><code>Input: Give me a summary of the movie:('c477e9d08ca546c8b0c4fdc3aa1f7a9e', 'The Princess \nBride')                                                                                                 </code></pre> <p>This is better, but it still provides more information than we need, as we really just want the movie name.</p>"},{"location":"200/compare-movies-workflow/05_using_tools/#option-3-use-the-for-loop","title":"Option 3: Use the For Loop","text":"<p>You may recall we're using a Jinja2 for loop (<code>{% for item in list %}</code>) structure in our <code>compare_task</code>.</p> <p>We can use the same structure here, even though there's only one item. <pre><code>\"\"\"Give me a summary of the movie:\n{% for key, value in inputs.items() %}\n{{ value }}\n{% endfor %}\n\"\"\"\n</code></pre></p>"},{"location":"200/compare-movies-workflow/05_using_tools/#compare-all-options","title":"Compare all options","text":"<p>As you can see, there are multiple ways to get the result we're looking for. Review the options below to see how they are unique. </p> All ItemsFilter For OneFor Loop <pre><code># code\nsummary_task = ToolkitTask(\n\"Give me a summary of the movie: {{ inputs.items() }}\",\ntools=[WebScraper()]\n)\n# result\ndict_items([('aff5c7989898483c93a14f40467ec2be', 'The Princess Bride')])                \n</code></pre> <pre><code># code\nsummary_task = ToolkitTask(\n\"Give me a summary of the movie: {{ inputs.items()|list|last }}\",\ntools=[WebScraper()]\n)\n# result\n('c477e9d08ca546c8b0c4fdc3aa1f7a9e', 'The Princess Bride')\n</code></pre> <pre><code># code\nsummary_task = ToolkitTask(\n\"\"\"\n    Give me a summary of the movie:\n    {% for key, value in inputs.items() %}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\ntools=[WebScraper()]        \n)\n# result\nThe Princess Bride\n</code></pre> <p>While the third option (using the for loop) is the longest, the result of just the name of the movie is cleanest - so for this example that's what we'll use.</p>"},{"location":"200/compare-movies-workflow/05_using_tools/#add-toolkittask","title":"Add ToolkitTask","text":"<p>Inside the <code>for description in movie_descriptions:</code> loop, add the <code>summary_task</code> after the <code>movie_task</code> but before the call to the <code>add_task</code> method of <code>workflow.</code></p> <pre><code># ...\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\nmovie_task = PromptTask(\n\"What movie title is this? Return only the movie name: {{ description }} \",\ncontext={\"description\": description})\nsummary_task = ToolkitTask(\n\"\"\"\n        Give me a summary of the movie:\n        {% for key, value in inputs.items() %}\n        {{ value }}\n        {% endfor %}\n        \"\"\",\ntools=[WebScraper()]\n)\nworkflow.add_task(movie_task)\n# ...\n</code></pre>"},{"location":"200/compare-movies-workflow/05_using_tools/#insert-summary-task","title":"Insert Summary Task","text":"<p>At the moment we've created the Summary Task for each movie, but we haven't inserted them into the workflow.</p> <pre><code>graph TB\n    A(Movie Descriptions) --&gt; B(\"PromptTask: Movie Task 1\") --&gt; I(\"PromptTask: Compare\")\n    C(\"ToolkitTask: Summary Task 1\"):::tool\n    H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\"):::tool-dash\n    A --&gt; G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash  --&gt; I\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n</code></pre> <p>To insert them, we'll need to update the <code>movie_task.add_child</code> method to call <code>summary_task</code> instead of <code>compare_task</code>. Then we'll add a call to <code>summary_task.add_child</code> to add <code>compare_task</code> to it.</p> <p>Inside the <code>movie_description</code> for loop, after <code>workflow.add_task(movie_task)</code> modify the code to look like:</p> <pre><code># ...\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\n# ...\nworkflow.add_task(movie_task)\nmovie_task.add_child(summary_task)\nsummary_task.add_child(compare_task)\n# ...\n</code></pre> <p>Now the workflow graph looks like we expect:</p> <pre><code>graph TB\n    A(Movie Descriptions) --&gt; B(\"PromptTask: Movie Task 1\") --&gt; C(\"ToolkitTask: Summary Task 1\"):::tool --&gt; I(\"PromptTask: Compare\")\n    A --&gt; G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash  --&gt; H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\"):::tool-dash\n    H --&gt; I\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n</code></pre>"},{"location":"200/compare-movies-workflow/05_using_tools/#handling-rate-limit","title":"Handling Rate Limit","text":"<p>You may find through your testing that you run into <code>RateLimitErrors</code> where the Rate limit is reached for gpt4 in your org. The messages look something like:</p> <pre><code>WARNING:root:&lt;RetryCallState 5541884496: attempt #1; slept for 0.0; last result: \nfailed (RateLimitError Rate limit reached for default-gpt-4 in organization org-abc123def456 on tokens per min. Limit: 40000 / min. Please try again in 1ms. Contact us through our help center at help.openai.com if you continue to have issues.)&gt;\n</code></pre> <p>This is a specific warning for OpenAI when your organization has hit it's assigned limit rate. You can read more about it in this article by OpenAI.</p> <p>You can work around this issue by specifically setting the <code>max_tokens</code> with the OpenAIPromptDriver.</p>"},{"location":"200/compare-movies-workflow/05_using_tools/#import-openaipromptdriver","title":"Import OpenAiPromptDriver","text":"<p>In your <code>griptape</code> input statements at the top of your script, add the following line:</p> <pre><code>from griptape.drivers import OpenAiPromptDriver\n</code></pre>"},{"location":"200/compare-movies-workflow/05_using_tools/#create-the-driver","title":"Create the driver","text":"<p>Now create a driver object for the OpenAiPromptDriver class. Note, you can add this anywhere before your first call to a <code>PromptTask</code>. I recommend calling it before <code>workflow</code>.</p> <pre><code># Define the OpenAiPromptDriver with Max Tokens\ndriver = OpenAiPromptDriver(\nmodel=\"gpt-4\",\nmax_tokens=500 # you can experiment with the number of tokens\n)\n</code></pre>"},{"location":"200/compare-movies-workflow/05_using_tools/#update-the-tasks","title":"Update the Tasks","text":"<p>For <code>compare_task</code>, <code>movie_task</code>, and <code>summary_task</code> calls, add the <code>driver</code> parameter.</p> <pre><code># ...\ncompare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {% for key, value in inputs.items() %}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\ndriver=driver\nid=\"compare\"\n)\n# ...\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\nmovie_task = PromptTask(\n\"What movie title is this? Return only the movie name: {{ description }} \",\ncontext={\"description\": description},\ndriver=driver\n)\nsummary_task = ToolkitTask(\n\"\"\"\n        Give me a very short summary of the movie from imdb:\n        {% for key, value in inputs.items() %}\n        {{ value }}\n        {% endfor %}\n        \"\"\",\ntools=[WebScraper()],\ndriver=driver\n)\n# ...\n</code></pre> <p>Tip</p> <p>Notice we are defining the driver per task. This means you can use different drivers for each task. You may find that some tasks work absolutely fine with the <code>gpt-3.5-turbo</code> model instead of <code>gpt-4</code>. Or, if you've trained your own model for a specific task you can use that as well. The possibilities are endless. </p>"},{"location":"200/compare-movies-workflow/05_using_tools/#test","title":"Test","text":"<p>Execute the code and let's review the output logs.</p> <p>Note</p> <p>I've removed the timestamps from the logs to make it easier to read. Yours will most likely still have them.</p> <pre><code>INFO Task compare                                  Input:                                                                                                  How are these movies the same:                                                                      The movie \"E.T. the Extra-Terrestrial\" is about a troubled child who summons the courage to help a  friendly alien escape from Earth and return to his home planet.                                         \"Jaws\" is a movie about a killer shark that unleashes chaos on a beach community off Cape Cod. It's \n    up to a local sheriff, a marine biologist, and an old seafarer to hunt the beast down. The shark        \n    terrorizes the community, affecting the number of tourists that usually flock to the island. After many \n    attempts, the shark won't go away, leading the sheriff, the marine biologist, and the seafarer to decide\n    to go after the shark and kill it.                                                                      The movie \"The Princess Bride\" is about a bedridden boy's grandfather who reads him the story of a  farmboy-turned-pirate. This farmboy encounters numerous obstacles, enemies, and allies in his quest to  be reunited with his true love. The movie is known for its satirical humor, great dialogue, and fun     adventure scenes. It is whimsical and romantic while also poking fun at the conventions of the fairy    tale genre. INFO Task compare                                  Output: While these three movies, \"E.T. the Extra-Terrestrial\", \"Jaws\", and \"The Princess Bride\", seem  very different in terms of plot and genre, they do share some similarities. All three films involve a   central conflict that requires the main characters to overcome significant challenges. In \"E.T.\", the   child must help the alien return home, in \"Jaws\", the characters must hunt down a dangerous shark, and  in \"The Princess Bride\", the farmboy-turned-pirate must overcome obstacles to reunite with his love.    Each movie also explores themes of courage, friendship, and determination. Furthermore, they are all    iconic films that have left a significant impact on popular culture.                                    </code></pre> <p>As you can see, the <code>compare</code> task has a lot more detail in it now. We're getting great summaries of the films, and therefore the output is even more detailed and valuable.</p> <p>Experiment</p> <p>You could enhance this output by providing more detail to the prompt compare prompt. For example, instead of just asking how they're the same, some options:</p> <ul> <li>\"Act as a movie critic. Why are these movies relevant to society?\"</li> <li>\"Act as a film studies professor. What are common themes in these movies?\"</li> </ul> <p>Hot Tip</p> <p>Instead of modifying the prompt, try using Rules and Rulesets to give your workflow more specific behavior.</p> <p>You can learn about Rulesets in the Multi Persona Chatbot course. </p>"},{"location":"200/compare-movies-workflow/05_using_tools/#code-review","title":"Code Review","text":"<p>We added some of helpful functionality in this section, mainly getting wonderful descriptions of these films from the web by using the <code>WebScraper</code> tool and <code>ToolkitTasks</code>. We also added the use of the <code>OpenAiPromptDriver</code> to control the <code>max_tokens</code> being used.</p> <p>Review your code.</p> app.py<pre><code>from dotenv import load_dotenv\n# Griptape \nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask, ToolkitTask\nfrom griptape.tools import WebScraper\nfrom griptape.drivers import OpenAiPromptDriver\n# Load environment variables\nload_dotenv()\n# Define the OpenAiPromptDriver with Max Tokens\ndriver = OpenAiPromptDriver(\nmodel=\"gpt-4\",\nmax_tokens=500\n)\n# Create a Workflow\nworkflow = Workflow()\n# Create a list of movie descriptions\nmovie_descriptions = [\n\"A boy discovers an alien in his back yard\",\n\"A shark attacks a beach\",\n\"A princess and a man named Wesley\"\n]\ncompare_task = PromptTask(\"\"\"\n    How are these movies the same:\n    {% for key, value in inputs.items() %}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\ndriver=driver,\nid=\"compare\")\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\nmovie_task = PromptTask(\n\"What movie title is this? Return only the movie name: {{ description }} \",\ncontext={\"description\": description},\ndriver=driver\n)\nsummary_task = ToolkitTask(\n\"\"\"\n        Give me a very short summary of the movie from imdb:\n        {% for key, value in inputs.items() %}\n        {{ value }}\n        {% endfor %}\n        \"\"\",\ntools=[WebScraper()],\ndriver=driver\n)\nworkflow.add_task(movie_task)\nmovie_task.add_child(summary_task)\nsummary_task.add_child(compare_task)\n# Run the workflow\nworkflow.run()\n</code></pre>"},{"location":"200/compare-movies-workflow/05_using_tools/#next-step","title":"Next Step","text":"<p>Congratulations, we've got a working movie comparison application! We can add a list of movies to compare, and the result is a detailed comparison that provides valuable insight as to how these movies can impact society.</p> <p>However, we're currently only viewing the results in the logs. If we want to use this data inside an application, we need to get the output of the workflow.</p> <p>In the next section, we'll learn how Workflows handle the output of their tasks and grab just the value of the summary task. Saunter over to Workflow Outputs when you're ready.</p>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/","title":"Workflow Outputs","text":""},{"location":"200/compare-movies-workflow/06_workflow_outputs/#overview","title":"Overview","text":"<p>In the previous section we added a <code>ToolkitTask</code> that used the <code>WebScraper</code> tool to get detailed information about the movies presented.</p> <p>In this section, we'll add the ability to get the <code>output</code> from the <code>workflow</code> in order to integrate it with whatever application we may be building.</p> <pre><code>graph TB\n    A(Movie Descriptions) --&gt; B(\"PromptTask: Movie Task 1\") --&gt; C(\"ToolkitTask: Summary Task 1\"):::tool --&gt; I(\"PromptTask: Compare\")\n    A --&gt; G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash  --&gt; H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\"):::tool-dash\n    H --&gt; I\n    I --&gt; J([\"\\n  Incredible movie insights. \\n\\n\"]):::output\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n    classDef output fill:#5552,stroke:#555\n</code></pre>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/#workflow-output_tasks","title":"Workflow Output_Tasks","text":"<p>If you look at our current workflow in detail, you will notice that it has a single node that has no children - the <code>Compare</code> node.</p> <p>Whenever our workflow runs, that final node is the last one that will evaluate. However, this isn't always necessarily the case. Imagine a situation where you have  multiple final tasks. For example - Saving multiple versions of these summaries to disk, or saving the state of an evaluation. You may have multiple tasks with no children.</p> <pre><code>graph TB\n    A(Movie Descriptions) \n    B(\"PromptTask: Movie Task 1\")\n    C(\"ToolkitTask: Summary Task 1\"):::tool\n    I(\"PromptTask: Compare\")\n    G(\"PromptTask: Movie Task &lt;i&gt;n&lt;/i&gt;\" ):::dash\n    H(\"ToolkitTask: Summary Task &lt;i&gt;n&lt;/i&gt;\"):::tool-dash\n    J([\"\\n  Incredible movie insights. \\n\\n\"]):::output\n    K(\"ToolkitTask: Save Summary\"):::tool\n    L(\"ToolkitTask: Save Summary &lt;i&gt;n&lt;/i&gt;\"):::tool-dash\n\n    A --&gt; B --&gt; C \n    C --&gt; K\n    C --&gt; I\n    A --&gt; G --&gt; H --&gt; I\n    H --&gt; L\n    I --&gt; J\n\n    classDef dash stroke-dasharray: 5 5\n    classDef tool stroke:#f06090\n    classDef tool-dash stroke:#f06090,stroke-dasharray: 5 5\n    classDef output fill:#5552,stroke:#555\n</code></pre> <p>In this case you would have at least 3 nodes that \"finish\" the workflow.</p> <p>Luckily, the <code>workflow</code> class has an <code>output_tasks</code> method that will return all the output tasks of your workflow.</p>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/#list-output-task","title":"List Output Task","text":"<p>To get a list of output tasks that are available on a workflow, you can simply do:</p> <pre><code>tasks = workflow.output_tasks()\n</code></pre> <p>For example, if we want to print the <code>id</code> and see the <code>prompt_template</code> of the output tasks of our workflow, you can comment out the <code>workflow.run()</code> call so it doesn't execute, and then iterate through the output_tasks printing the <code>id</code> and <code>prompt_template</code>.</p> <pre><code># ...\n# Run the workflow\n# workflow.run()            &lt;-- Commented out\nfor task in workflow.output_tasks():\nprint(f\"id: {task.id}\")\nprint(f\"prompt_template: {task.prompt_template}\")\n</code></pre> <p>Execute this and you should see the id and template of the final task.</p> <p>Note</p> <p>When you execute this code you are not running the workflow, you're just getting information about each node.</p> <pre><code>id: compare\nprompt_template: \n    How are these movies the same: \n    {% for key, value in inputs.items() %}\n    {{ value }}\n    {% endfor %}\n</code></pre>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/#workflow-attributes","title":"Workflow Attributes","text":"<p>To see what other attributes are available on the workflow, go ahead and use the <code>dir</code> function.</p> <pre><code># use dir() to get all the attributes of the task.\n# note: we're using workflow.output_tasks()[0] to just reference the \n# first output_task.\nprint (dir(workflow.output_tasks()[0]))\n</code></pre> <p>The result: <pre><code>['DEFAULT_PROMPT_TEMPLATE', 'State', '__abstractmethods__', '__annotations__', '__attrs_attrs__', '__attrs_own_setattr__', \n'__class__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',\n'__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lshift__', '__lt__',\n'__match_args__', '__module__', '__ne__', '__new__','__reduce__', '__reduce_ex__', '__repr__',\n'__rshift__', '__setattr__', '__setstate__', '__sizeof__', '__slots__', '__str__',\n'__subclasshook__', '__weakref__', '_abc_impl', 'active_driver', 'add_child', 'add_parent', 'after_run',\n'before_run', 'can_execute', 'child_ids', 'children', 'context', 'driver', 'execute', 'full_context', 'id', \n'input', 'is_executing', 'is_finished', 'is_pending', 'output', 'parent_ids', 'parents', 'prompt_stack', \n'prompt_template', 'render', 'reset', 'run', 'state', 'structure']\n</code></pre></p> <p>Notice that this includes all the \"special\" attributes (also known as <code>dunder</code>) and methods. We can filter those out by using list comprehension.</p> <pre><code>filtered_attributes = [attr for attr in dir(workflow.output_tasks()[0]) if not (attr.startswith('__') and attr.endswith('__'))]\nprint(filtered_attributes)\n</code></pre> <p>This will give us a much nicer group of attributes to work with:</p> <pre><code>['DEFAULT_PROMPT_TEMPLATE', 'State', '_abc_impl', 'active_driver', 'add_child', 'add_parent', 'after_run', \n'before_run', 'can_execute', 'child_ids', 'children', 'context', 'driver', 'execute', 'full_context', 'id', \n'input', 'is_executing', 'is_finished', 'is_pending', 'output', 'parent_ids', 'parents', 'prompt_stack', \n'prompt_template', 'render', 'reset', 'run', 'state', 'structure']\n</code></pre> <p>There are a number of interesting attributes in there for you to check out, but the one we care about in this case is going to be <code>output</code>.</p>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/#output-value","title":"Output Value","text":"<p>To print the <code>output.value</code> we can do the following:</p> <pre><code># Run the workflow\nworkflow.run()          # &lt;-- re-enabled so the workflow will run\nfor task in workflow.output_tasks():\nprint(task.output.value)    \n</code></pre>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/#test","title":"Test","text":"<p>Execute the code and let's review the output.</p> <pre><code>While these movies - \"E.T. the Extra-Terrestrial\", \"Jaws\", \nand \"The Princess Bride\" - have different plots and settings, \nthey share some common elements. All three films involve \ncharacters facing significant challenges and overcoming them. \nThey also all involve elements of adventure and suspense. \nAdditionally, they were all released in the 20th century and \nhave become iconic films in American cinema.\n</code></pre>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/#code-review","title":"Code Review","text":"<p>I this final section we learned out to get the <code>output</code> from the <code>workflow</code> in order to be able to integrate this workflow into our application.</p> <p>Review your code.</p> app.py<pre><code>from dotenv import load_dotenv\n# Griptape \nfrom griptape.structures import Workflow\nfrom griptape.tasks import PromptTask, ToolkitTask\nfrom griptape.tools import WebScraper\nfrom griptape.drivers import OpenAiPromptDriver\n# Load environment variables\nload_dotenv()\n# Define the OpenAiPromptDriver with Max Tokens\ndriver = OpenAiPromptDriver(\nmodel=\"gpt-4\",\nmax_tokens=500\n)\n# Create a Workflow\nworkflow = Workflow()\n# Create a list of movie descriptions\nmovie_descriptions = [\n\"A boy discovers an alien in his back yard\",\n\"a shark attacks a beach.\",\n\"A princess and a man named Wesley\"\n]\ncompare_task = PromptTask(\"\"\"\n    How are these movies the same: \n    {% for key, value in inputs.items() %}\n    {{ value }}\n    {% endfor %}\n    \"\"\",\ndriver=driver,\nid=\"compare\")\n# Iterate through the movie descriptions\nfor description in movie_descriptions:\nmovie_task = PromptTask(\n\"What movie title is this? Return only the movie name: {{ description }} \",\ncontext={\"description\": description},\ndriver=driver\n)\nsummary_task = ToolkitTask(\n\"\"\"\n        Give me a very short summary of the movie from imdb:\n        {% for key, value in inputs.items() %}\n        {{ value }}\n        {% endfor %}\n        \"\"\",\ntools=[WebScraper()],\ndriver=driver\n)\nworkflow.add_task(movie_task)\nmovie_task.add_child(summary_task)\nsummary_task.add_child(compare_task)\n# Run the workflow\nworkflow.run()\n# View the output\nfor task in workflow.output_tasks():\nprint(task.output.value)    \n</code></pre>"},{"location":"200/compare-movies-workflow/06_workflow_outputs/#finished","title":"Finished","text":"<p>Success</p> <p>Congratulations! You have created a successful Griptape Workflow!</p> <p>Well done, you've successfully created a Griptape Workflow that allows you to execute complex and interesting dependency graphs.</p> <p>You have learned how to:</p> <ul> <li>Create tasks that can handle prompts and tools</li> <li>Learned a bit about Jinja2 templates</li> <li>Create parent/child relationships</li> <li>Create tasks that are depending on multiple incoming tasks</li> <li>Get the output from a workflow for integration with other applications.</li> </ul> <p>We hope you enjoyed this course, and look forward to seeing what you're able to create with these new skills.</p>"},{"location":"300/","title":"300 Advanced - \"The Ollie\"","text":"<p>Delve deeper into the intricate workings of Griptape with our Advanced courses. Prepare yourself for a comprehensive exploration of high-level concepts, technical details, and extensive use cases. These in-depth courses are designed to satisfy your thirst for knowledge and challenge your understanding, opening doors to advanced Griptape applications and boosting your coding prowess.</p> <p>Why Ollie?</p> <p>The ollie is a fundamental skateboarding trick that involves leaping into the air without the use of the rider's hands, but rather by exerting pressure on the tail of the board while jumping. Named after its inventor, Alan \"Ollie\" Gelfand, the trick requires skill and practice, much like our Advanced courses, where you delve deeper into the intricate workings and technical details of Griptape.</p>"},{"location":"400/","title":"400 Expert - \"McTwist\"","text":"<p>Step into the realm of the extraordinary with our Expert courses, where Griptape truly shines. This is where we push the boundaries of what's possible, showcasing how to leverage Griptape to create insanely awesome AI systems. These courses are designed for those who dare to innovate, reinvent, and redefine the landscape of AI, leading the charge in the revolution of generative AI.</p> <p>What's a McTwist?</p> <p>The McTwist is an extremely difficult skateboarding trick, invented by Mike McGill, involving a 540-degree flip while the skater is airborne. It's a daring move that demands a high level of skill and confidence, perfectly symbolizing our Expert level where we push the boundaries of what's possible with Griptape, and you become a master of your craft. It's called the McTwist as a homage to its creator, McGill.</p>"},{"location":"setup/","title":"Setting Up Your Python Environment for Griptape","text":""},{"location":"setup/#kickoff-and-foundations","title":"Kickoff and Foundations","text":"<p>Welcome to the getting started course for Griptape. We'll be using Visual Studio Code and the Griptape library, which make a great combo for coding with Large Language Models (LLMs). </p>"},{"location":"setup/#what-will-i-learn","title":"What will I learn?","text":"<p>By the end of the course you will have the ability to use Griptape to work with Large Language Models. You will be setting up your Python environment, install a code editor, install Griptape, and be ready to go.</p> griptape_developer.py<pre><code>from dotenv import load_dotenv\nfrom griptape.structures import Agent\nload_dotenv()\n# Create an agent\nagent = Agent()\n# Run the agent\nagent.run(\"Hello! I'm a new Griptape Developer!\")\n</code></pre>"},{"location":"setup/#who-is-this-course-for","title":"Who is this course for?","text":"<p>This course is aimed at beginners to intermediate level Python developers who are interested in setting up a Python environment to develop tools and applications with Griptape.</p>"},{"location":"setup/#why-visual-studio-code","title":"Why Visual Studio Code?","text":"<p>Using the right coding software (or Integrated Development Environment - IDE) can make your coding sessions a breeze... or not (if you choose the wrong one).</p> <p>Visual Studio Code (VS Code for short) is our IDE of choice for a few reasons. It's lightweight, highly customizable, and has a vast range of extensions. </p>"},{"location":"setup/#griptape-and-python","title":"Griptape and Python","text":"<p>Griptape provides a simple, Pythonic interface to interact with these models, taking care of the complexities so we can focus on coding our applications. </p> <p>In the next stages, we will be going through:</p> <ul> <li> <p>Setting Up: Here, we will install and set up the basic tools we need: Visual Studio Code, Python, and create our directory structure. We'll also ensure that you have the right Python environment in place.</p> </li> <li> <p>OpenAI API Key: Before jumping into Griptape, we need to get our OpenAI API Key and set up our environment so it's ready.</p> </li> <li> <p>Griptape: We'll install the Griptape library and send our first message to the LLM!</p> </li> </ul> <p>Are you ready to get started? Let's move on to Setting up your environment!</p>"},{"location":"setup/01_setting_up_environment/","title":"Software","text":""},{"location":"setup/01_setting_up_environment/#overview","title":"Overview","text":"<p>Setting up our development environment correctly is vital for smooth and successful coding. In this stage, we'll go through all the necessary installations and configurations.</p>"},{"location":"setup/01_setting_up_environment/#installing-python","title":"Installing Python","text":"<p> Before getting started with Griptape, you'll need to install Python.</p> <p>Info</p> <p>Griptape requires a minimum Python version of 3.9, but feel free to install a more recent version if you wish. </p>"},{"location":"setup/01_setting_up_environment/#windows-or-linux","title":"Windows or Linux","text":"<ol> <li>Head over to the official Python downloads page</li> <li>Click on the button that says \"Python 3.9.x\" (or the most recent 3.9 version) to download the installer</li> <li>Run the installer, and make sure to check the box that says \"Add Python 3.9 to PATH\" before you click \"Install Now\"</li> </ol>"},{"location":"setup/01_setting_up_environment/#macos","title":"macOS","text":"<p>If you have Homebrew installed:</p> <ol> <li>Open your terminal</li> <li>Run the <code>command brew install python@3.9</code></li> <li>After the installation is complete, run <code>brew link python@3.9</code></li> </ol> <p>Info</p> <p>If you don't have Homebrew, you can install Python from the official website as mentioned above.</p> <p>You did it!</p> <p>Congratulations, you've got Python!</p>"},{"location":"setup/01_setting_up_environment/#visual-studio-code","title":"Visual Studio Code","text":""},{"location":"setup/01_setting_up_environment/#installing","title":"Installing","text":"<p>Visual Studio Code (VS Code) provides the perfect environment for our Python coding.</p> <ol> <li>Go to the VS Code download page</li> <li>Download the version appropriate for your OS (Windows, Linux, or macOS)</li> <li>Run the installer and follow the prompts</li> </ol> <p>Success</p> <p>VS Code is now installed!</p>"},{"location":"setup/01_setting_up_environment/#creating-the-project-folder","title":"Creating the Project Folder","text":"<p>Before we dive into coding, let's create a dedicated space for our project. Having a clean organized directory structure makes coding and managing your projects much easier.</p> <p>First, you'll want to create a new folder on your computer where all the code for this project will live. You can create this folder anywhere you like. Here's how you can do it via your Terminal:</p> <pre><code>mkdir griptape-starter\ncd griptape-starter\n</code></pre> <p>This creates a new folder called \"griptape_intro\" and moves into it.</p> <p>Alternatively, feel free to open up Visual Studio Code and create a new folder: 1. Choose File -&gt; Open Folder.. 1. Choose New Folder 1. Enter the name of your new folder. Example: <code>griptape-starter</code> 1. Choose Create 1. Double-click on the newly created folder to open it.</p>"},{"location":"setup/01_setting_up_environment/#virtual-environments","title":"Virtual Environments","text":""},{"location":"setup/01_setting_up_environment/#using-vs-codes-python-environment-manager","title":"Using VS Code's Python Environment Manager","text":"<p>Python virtual environments are essential tools for keeping your projects organized and isolated. They allow each project to have its own set of dependencies, ensuring that different projects won't interfere with each other, which is vital when different projects require different versions of the same library. By using virtual environments, you can maintain a clean, conflict-free workspace for each project, making it easier to manage your code and troubleshoot any issues.</p> <p>Many developers use their terminal to manage their Python virtual environments. As this is a beginner level course, we'll use an Extension inside VS Code instead because it makes this a little bit easier.</p> <ol> <li>With VS Code open, go to the Extensions tab, or choose View --&gt; Extensions</li> <li>Search for <code>Python Environment Manager</code>, or go to Python Environment Manager in your web browser.</li> <li>Choose <code>Install</code></li> <li>Open the Command Palette (<code>Ctrl</code>+<code>Shift</code>+<code>P</code> on Windows/Linux, <code>Cmd</code>+<code>Shift</code>+<code>P</code> on macOS), or choose View --&gt; Command Palette..</li> <li> <p>Search for <code>Python: Create Environment</code> and you should see it come up at the top of the command list.     </p> </li> <li> <p>Hit return with that item selected and choose <code>.Venv: Creates a '.venv' virtual environment in the current workspace</code></p> <p></p> </li> <li> <p>Then choose a python version.</p> <p></p> <p>Note: This will create the virtual environment for you within the current directory. </p> <ul> <li>This creates a new virtual environment in a folder called <code>.venv</code> and activates the environment for you.</li> </ul> </li> </ol> <p>Now you've set up your Python environment for this project. This way, anything you install or change in Python won't affect other projects.</p>"},{"location":"setup/01_setting_up_environment/#confirm-its-working","title":"Confirm it's working","text":"<p>To be sure that your virtual environment is set up correctly, we'll check by opening a Terminal. If everything is set correctly, you'll see <code>.venv</code> in your terminal prompt.</p> <ol> <li>Open the terminal in VS Code by clicking on <code>Terminal -&gt; New Terminal</code></li> </ol> <p></p> <p>Note</p> <p>You should see <code>.venv</code> in your prompt. If you don't see it, please run through the previous documentation to try again. </p>"},{"location":"setup/01_setting_up_environment/#next-step","title":"Next Step","text":"<p>You now have Python and VS Code installed, and you've got a working virtual environment! In the next section, we'll set up your OpenAI API key so you can communicate with their large language model. </p>"},{"location":"setup/02_openai/","title":"OpenAI","text":""},{"location":"setup/02_openai/#overview","title":"Overview","text":""},{"location":"setup/02_openai/#openai","title":"OpenAI","text":""},{"location":"setup/02_openai/#obtaining-the-api-key","title":"Obtaining the API Key","text":"<p>In order to communicate with an LLM using Griptape, we'll need a key. To do this, we'll grab an API key from OpenAI.</p> <p>Tip</p> <p>Griptape can work with many large language models, but to keep things simple for now, we'll just focus on OpenAI's gpt model.</p> <ol> <li>Go to the OpenAI website and sign up for an account if you don't have one already.</li> <li> <p>After logging in, navigate to the API section of your dashboard.</p> <p></p> </li> <li> <p>Choose Create a new secret key in order to create a key for your use.</p> </li> <li> <p>Give your key a name. Example: <code>griptape</code></p> <p></p> </li> <li> <p>Choose Create secret key</p> </li> <li> <p>You will see a window with your new key highlighted. You will not be able to view this key again so it's very important to copy the key and save it somewhere safe.</p> <p></p> </li> <li> <p>Choose Done</p> </li> </ol> <p>Warning</p> <p>Remember, this API key is like your secret key to the city of LLMs. Don't share it with anyone!</p>"},{"location":"setup/02_openai/#installing-python-dotenv","title":"Installing python-dotenv","text":"<p>Understanding and using environment variables is a key aspect of programming. In order to use the API key we just received, we will need to be able to access it from with our python script. We'll use a package called python-dotenv to handle environment variables in our project.</p> <p>In the terminal, run the command <code>pip install python-dotenv</code> to install the package.</p> <p></p>"},{"location":"setup/02_openai/#creating-the-env-file-and-setting-the-openai-api-key","title":"Creating the .env File and Setting the OpenAI API Key","text":"<p>Now that we have our OpenAI API key, we need to make it available for our Python code to use. The best and safest way to do this is using a <code>.env</code> file, which allows us to define environment variables. We can then use the <code>load_dotenv</code> library to access any of those environment variables..</p> <ol> <li>In the root of your project folder (<code>griptape-starter</code>), create a new file and name it <code>.env</code>.</li> <li>Open the <code>.env</code> file and write <code>OPENAI_API_KEY=your_openai_api_key_here</code>, replacing <code>your_openai_api_key_here</code> with your actual OpenAI API key.</li> <li>Save the file.</li> </ol> .env<pre><code>OPENAI_API_KEY=your_openai_api_key_here \n</code></pre>"},{"location":"setup/02_openai/#your-first-app","title":"Your first app","text":""},{"location":"setup/02_openai/#creating-apppy","title":"Creating app.py","text":"<p>Now we're going to create our Python file and use the <code>python-dotenv</code> library to load the <code>OPENAI_API_KEY</code> environment variable. First things first, let's create a Python file where we will write our code.</p> <ol> <li>In your project directory (<code>griptape-starter</code>), create a new file called <code>app.py</code>. You can do this in VS Code by clicking <code>File -&gt; New File</code></li> <li>Save the file by choosing <code>File -&gt; Save As...</code></li> <li>Entering <code>app.py</code> as the filename.</li> </ol> <p>Success</p> <p>Nice, you've created your first Python file! </p>"},{"location":"setup/02_openai/#importing-the-library","title":"Importing the Library","text":"<p>Next, we're going to import the <code>load_dotenv</code> function from the <code>dotenv</code> library we installed earlier.</p> <p>Enter the following code in app.py.</p> app.py<pre><code>from dotenv import load_dotenv\n</code></pre>"},{"location":"setup/02_openai/#loading-the-variables","title":"Loading the variables","text":"<p>Now we'll use the <code>load_dotenv</code> function. Update your <code>app.py</code> with the highlighted line: app.py<pre><code>from dotenv import load_dotenv\nload_dotenv() # Load the environment variables\n</code></pre></p> <p>If you save and run your script, you shouldn't get any errors in your Terminal. If you received no errors.. you win! You've loaded your environment variable that was specified in the <code>.env</code> file!</p>"},{"location":"setup/02_openai/#next-steps","title":"Next Steps","text":"<p>Congratulations! Your environment is set, and your application is ready. You're ready to start using Griptape! In the next section, we'll install Griptape and send our first message to the LLM. I wonder what it'll say...</p>"},{"location":"setup/03_griptape/","title":"Griptape","text":""},{"location":"setup/03_griptape/#overview","title":"Overview","text":"<p>Now that you've got your environment all set up, it's time to actually start moving. In this stage, we'll put together a basic Griptape application and see it in action. </p>"},{"location":"setup/03_griptape/#our-application","title":"Our Application","text":"<p>We are going to build a very simple application. It's going to simply take in a prompt, and return the result of that prompt. For example, we will be able to ask: \"What's a good place to visit in New Zealand?\" and it will give us an answer like \"Abel Tasman\" or \"All of it\".</p>"},{"location":"setup/03_griptape/#griptape","title":"Griptape","text":""},{"location":"setup/03_griptape/#agents","title":"Agents","text":"<p>There are multiple ways communicate with LLMs via Griptape, but the one we'll use in this example is an Agent. You can learn more about Agents in documentation, but here's a simple way to understand them:</p> <p>Abstract</p> <p>Agents can do one task.</p> <p>You give the Agent a prompt, it thinks for a bit, figures things out, and then returns a result. While that sounds relatively simple, it's actually quite cool. You can give the agent tools (WebScraper, Calculator, EmailClient, to name a few), you can give it rules about how to behave, and more. Agents can actually do quite a lot - but they're still one of the more simple ways of interacting with Griptape, which is why we'll use them to start with in this course.</p> <p>Speaking of interacting with Griptape... we need to install it!</p>"},{"location":"setup/03_griptape/#installing-griptape","title":"Installing Griptape","text":"<p>Just like we installed the <code>python_dotenv</code> library, we need to do the same with Griptape. </p> <p>Open your Terminal and use <code>pip</code> to install both <code>griptape</code> and <code>griptape-tools</code>:</p> <pre><code>pip install griptape griptape-tools\n</code></pre> <p>Info</p> <p>This will take a minute to install. Another chance to enjoy a !</p>"},{"location":"setup/03_griptape/#import-griptape","title":"Import Griptape","text":"<p>Now comes the moment you've all been waiting for! Actually, it's the moment before the moment. In this moment, we're going to import the Agent from the Griptape library. The moment after that is probably the one you're really waiting for. But we have to do this moment first. Live in the now.</p> <p>Modify your <code>app.py</code> to import the agent</p> app.py<pre><code>from dotenv import load_dotenv\nfrom griptape.structures import Agent\nload_dotenv() # Load the environment variables\n</code></pre> <p>As you can see, we're importing the Agent from <code>griptape.structures</code>. There are other structures we can work with, but again.. this is just setting up your environment. We'll talk about those in another course.</p>"},{"location":"setup/03_griptape/#the-fun-part","title":"The fun part","text":""},{"location":"setup/03_griptape/#create-the-agent","title":"Create the Agent","text":"<p>To create the Agent, we'll instantiate the class. </p> app.py<pre><code>from dotenv import load_dotenv\nfrom griptape.structures import Agent\nload_dotenv() # Load the environment variables\n# Create the Agent\nagent = Agent()\n</code></pre>"},{"location":"setup/03_griptape/#run-the-agent","title":"Run the Agent","text":"<p>Now you get to tell the Agent what to do. Use the Agent's <code>run</code> method to execute a prompt.</p> app.py<pre><code>from dotenv import load_dotenv\nfrom griptape.structures import Agent\nload_dotenv() # Load the environment variables\n# Create the Agent\nagent = Agent()\n# Run the agent\nagent.run(\"Give me a haiku about skateboarding\")\n</code></pre>"},{"location":"setup/03_griptape/#test-the-agent","title":"Test the Agent","text":"<p>Let's see if our application works.</p> <ol> <li>Save your file.</li> <li>Use the Run icon in the upper right corner of VS Code, or open your terminal and type <code>python app.py</code>.</li> </ol> <p>If everything has been set up correctly, you should see the result of the <code>agent.run()</code> command printed in the terminal. The exact output will depend on the current configuration and performance of the OpenAI API, but it should be a haiku about skateboarding.</p> <pre><code>[07/21/23 05:39:22] INFO     Task 801254fc5df64cda8930917a8afbc5bc                                              Input: Create me a haiku about skateboarding                                       [07/21/23 05:39:24] INFO     Task 801254fc5df64cda8930917a8afbc5bc                                              Output: Skateboard glides swiftly,                                                 Tricks and flips in the air, high,                                                 Thrilling ride, pure bliss.      </code></pre> <p>Success</p> <p>Congrats! You've taken the first push and created your first python script that works with a large language model!</p>"},{"location":"setup/03_griptape/#next-steps","title":"Next Steps","text":"<p>You've successfully set up your development environment, installed the necessary packages, obtained your OpenAI API key, and written and run a simple Griptape application. You've done a great job, so don't forget to celebrate your progress. </p> <p>Now that you've successfully completed the course, please check out these Helpful Resources to learn more about Griptape!</p>"},{"location":"setup/04_helpful_resources/","title":"Resources","text":"<p>Congrats on reaching this stage! You've set up your environment, written your first Griptape application, and are ready to embark on your coding journey. However, learning is an ongoing process, and the more resources you have at your disposal, the more empowered you'll be to tackle whatever comes your way.</p> <p>Here's a list of resources to help you gain momentum and build your knowledge:</p>"},{"location":"setup/04_helpful_resources/#griptape","title":"Griptape","text":"<ul> <li> <p>Griptape Documentation: Learn everything you need to know about Griptape from its official documentation. You'll find detailed explanations, ../assets/examples, and tips here. Visit the Griptape Documentation.</p> </li> <li> <p>Griptape GitHub: Check out the official Griptape repository on GitHub. You can look at the source code, report issues, and even contribute. Here's the Griptape GitHub link.</p> </li> <li> <p>Griptape Discord Community: Join the Griptape community on Discord. Here, you can connect with other users, ask questions, share your projects, and keep up-to-date with Griptape developments. Here's the Griptape Discord link.</p> </li> </ul>"},{"location":"setup/04_helpful_resources/#tools","title":"Tools","text":"<ul> <li> <p>Visual Studio Code: Brush up on your VS Code knowledge. Check out the VS Code Documentation to get familiar with its features and functionalities.</p> </li> <li> <p>Python: Python's official documentation is a comprehensive resource that covers all aspects of the language. Visit the Python Documentation.</p> </li> <li> <p>Python-dotenv: Get more information about how to use the python-dotenv package from its Python-dotenv PyPI page.</p> </li> <li> <p>OpenAI API: Understand how OpenAI's API works. The OpenAI API Documentation is a great place to start.</p> </li> </ul>"},{"location":"setup/04_helpful_resources/#additional-links","title":"Additional Links","text":"<ul> <li>Language Learning Models (LLMs): Get a broader understanding of LLMs and how they're revolutionizing the field of AI. Here are some useful links:</li> <li>What are Language Models?</li> <li>Language Learning Models Explained</li> </ul> <p>These resources will give you a deeper understanding and greater control as you navigate the landscape of programming with Python and Griptape. Happy coding!</p>"}]}